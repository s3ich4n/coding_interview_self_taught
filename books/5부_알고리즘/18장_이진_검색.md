# 이진 검색

이진 검색: 정렬된 배열에서 타겟을 찾는 검색 알고리즘이다.

값을 찾는 시간복잡도가 O(log N)이다. 대표적인 로그 시간 알고리즘이다.

장점: 1억개의 아이템도 27번의 비교로 모두 찾을 수 있다.

잠깐 다른 이야기 하자면, O(2^n) 은 정말 끔찍하게 느리다.

# Q65) 이진 검색

정렬된 nums를 받아 이진 검색으로 target에 해당하는 인덱스를 찾으시오.

input)

```
nums = [-1, 0, 3, 5, 9, 12], target = 9
```

output)

```
4
```

## A1) 재귀 풀이

절반씩 범위를 줄이면서 맞을 때 까지 재귀호출하기. 재귀가 되면 반복도 된다. BFS 말고...

재귀 참고사항!

파이썬은 재귀호출에 대한 호출횟수 제한이 있다. 기본값은 `1,000`이다.

```
>>> import sys
>>> sys.getrecursionlimit()
1000
```

이진 검색에서 2^1000 의 값을 갖다가 찾으라고 하진 않으니까 상관없긴 하지만, 이를 항상 유념해두자.

## A2) 반복 풀이

재귀 풀이가 있다면 반복풀이로도 풀어보자.

## A3) `bisect` 사용

왼쪽/오른쪽 에서부터 인덱스를 구하고 처리하는 표준 라이브러리

## A4) 이진검색을 안쓰는 풀이

는 안볼거임. 갯수가 어느정도 넘어가면(대충 `100,000` 쯤) 성능이 `1,000` 배 이상 차이난다.

# Q66) 회전 정렬된 배열 검색

특정 피벗을 기준으로 회정하여 정렬된 배열에서 `target` 값의 인덱스를 구하시오.

input)

```
nums = [4, 5, 6, 7, 0, 1, 2]
target = 1
```

output)

```
5
```

설명)

1. 정렬된 입력값에서 target의 위치를 찾는다.
2. 원래 입력값에서 얼마나 돌아가있는지 확인한다.
3. (1의 위치 + 2의 위치) 를 리턴한다.

## A1) 피벗을 기준으로 한 이진검색

피벗이 가장 작은값으로 보이는데 이걸 피벗으로 둔다.

피벗을 찾는다. -> `pivot = nums.index(min(nums))`

binary search로 찾자. 최솟값 left를 찾아서 pivot으로 구성하고 이걸 기준으로 피벗 위치만큼 틀어준 `mid_pivot`을 구성한다. 그 다음 이진검색으로 target을 찾으면 된다.

### mid pivot?

`mid_pivot = (mid + pivot) % len(nums)`

중앙 mid에서 pivot만큼 이동한다
배열의 길이를 초과하면 모듈로 연산으로 회전한다

타겟과 값을 비교하는 부분은 mid가 아닌 `mid_pivot`을 기준으로 한다. left, right는 mid를 기준으로 한다.

### 참고

원래 이건 `argmin` 을 찾으면 끝이긴 하다. 이는 `numpy` 로 쉽게 구할 수 있다. -> `numpy.argmin()`

쌩으로 구하면 이렇다 -> `pivot = nums.index(min(nums))`

# Q67) 두 배열의 교집합

두 배열의 교집합을 구하시오.

예제 1 Input)

```
nums1 = [1, 2, 2, 1]
nums2 = [2, 2]
```

예제 1 Output)

```
[2]
```

예제 2 Input)

```
nums1 = [4, 9, 5]
nums2 = [9, 4, 9, 8, 4]
```

예제 2 Output)

```
[9, 4]
```

## A1) 브루트 포스

1. set 하나 만든다
2. 둘다 무한루프 돌려서 같은 값을 set에 넣는다

O(n^2)... 더 빨라야겠지..?

## A2) 이진검색으로 일치여부 판별

한쪽은 탐색하고 다른쪽은 정렬해서 이진검색으로 값을 찾으면 효율이 매우 좋아진다.

O(N log N). 이정도면...

## A3) 투 포인터로 일치여부 판별

양쪽 모두 정렬을 하고
투포인터를 우측으로 옮기면서 똑같은지 본다.

i, j 둘

# Q68) 두 수의 합 2

정렬된 배열을 받아 덧셈하여 타깃을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하시오.

이 문제에서 배열은 0이 아닌 1부터 시작한다.

Input)

```
numbers = [2, 7, 11, 15]
target = 9
```

Output)

```
[1, 2]
```

## A1) 투포인터

정렬된 시퀀스면 쓸 수 있다! 정렬 안됐을 때 못 썼던 풀이를 가져와보자...

```python
left, right = 0, len(nums) -1

while not left == right:
    if nums[left] + nums[right] < target:
        left += 1
    elif nums[left] + nums[right] > target:
        right -= 1
    else:
        return left, right
```

잘 동작한다. 놀랍게도 이러면 O(n)에 클리어.

## A2) 이진 검색

현재값을 기준으로 나머지가 맞는지 확인하는 이진검색으로도 가능하다.

이진검색 log N 을 N 번 반복하므로.. O(N log N) 이다. 따라서 조금 더 느리다.

## A3) `bisect` + 슬라이싱

더 느려짐. 슬라이싱을 잘못해서 그런 것으로 일단 파악.

## A4) `bisect` + 슬라이싱 최소화

A3보단 빨라지긴 했으나 느려짐. 개선책 필요.

## A5) `bisect` + 슬라이싱 제거

문제의 테스트케이스는 매우 큰 리스트를 만드는 것으로 보임. 슬라이싱은 매번 새 객체를 만들고 할당함. 큰 객체는 따라서 더 오래 걸릴 것임.

왼쪽 범위를 제한하는 리스트를 만들었다가 말았다가 하는게 반복됐기 때문에 성능하락이 있었던 것으로 예상됨.

따라서 `bisect` 본연의 기능으로 `lo`, `hi` 만 넣어줌으로서 알아서 해결하게끔 맡김.

# Q69) 2D 행렬 검색 II

m \* n 행렬에서 값을 찾아내는 효율적인 알고리즘을 구현하시오. 행렬은 아래와 같이 오름차순으로 정렬 되어있음.

- 왼쪽 -> 오른쪽
- 위 -> 아래

Input)

```
array = [
    [1,   4,  7, 11, 15],
    [2,   5,  8, 12, 19],
    [3,   6,  9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30],
]

target = 5      # True. 값이 있으므로
target = 20     # False. 값이 없으므로
```

## A1) 첫 행의 맨 뒤에서 탐색

### 어프로치

컬럼 기준으로 이진검색, 로우기준으로 이진검색?

인덱스 기반이라 연산이 많이 들 것 같다. 값 꺼내려고 해도 O(n) 이 드니까 O(log N)은 물건너갔다. 그리고 꺼내온 컬럼 안에 값이 있는지도 확신할 수 없다.

핵심로직:

**첫행 맨 뒤의 요소로부터 시작해서, 타겟이 작으면 왼쪽, 크면 아래로.**

정렬되어있으니까 가능함.

## A2) 파이썬스러운 방식

행렬안에 값이 있으면 꺼내오는 `any()` 를 쓰면 됨

아이러니하게도 이진검색이 아님. 문제가 예상대로 안풀리면 이 방식을 계속 붙잡고 있으면 안됨.
