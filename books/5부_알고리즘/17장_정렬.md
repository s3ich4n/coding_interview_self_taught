# 정렬

정렬 알고리즘: 값을 순서대로 넣는 알고리즘. 숫자식순서/사전식순서대로 정렬하는게 맞음.

빅오, 분할정복, 힙, 이진트리, 시간/공간의 트레이드오프 등을 다 다룸.

---

버블소트 하나 즉석에서 말 못한다고 일 못하는 사람 아니지만서도, 이걸 공부하는거는 일리있다. 대학교때 그 고생을 한걸 생각해보자. 그런 방법에 대해 학습한거다.

## 버블 정렬(Bubble Sort)

n번의 라운드를 O(n)만큼 살펴본다. 그래서 O(n^2) 다.

## 병합 정렬 (Merge Sort)

divide and conquer의 대표주자 `theta(n log n)` 이며, 안정 정렬이다.

못 쪼갤 때 까지 계속 분할하고, 분할한 이후 그걸 다시 정렬한다.

cf. 퀵 소트의 최악의 수는 O(n^2) 이고, 이는 정렬되어있거나, 역순정렬이 이미 된 값에 대해 수행할 때의 최악의 케이스다.

## 퀵 정렬 (Quick Sort)

피벗을 기준으로 좌우를 나눈다(파티션 교환 정렬임, Partition-Exchange Sort). pivot 보다 작으면 왼쪽, 크면 오른쪽으로...

로무토란 사람이 만든 파티션 계획을 살펴보자.

1. 항상 맨 오른쪽의 피벗을 택한다.
   1. 간결하고 이해하기는 쉽다. 아마 대학교 때도 그걸로 구현했을걸

## 안정 정렬 vs. 불안정 정렬

- 정렬된 것을 다시 정렬할 때 엉망이 되면 "불안정 정렬"
- 정렬된 값을 재정렬해도 되면 "안정 정렬"

- 불안정 정렬의 예시: 퀵 정렬
- 안정 정렬의 예시: 병합 정렬

파이썬은 기본적으로 병합정렬, [삽입정렬](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)을 휴리스틱하게 조합한 팀소트를 쓴다.

# Q58) 리스트 정렬

문제) 연결리스트를 O(n log n) 에 정렬하시오.

Input)

```
4->2->1->3
```

Output)

```
1->2->3->4
```

## A1) 병합정렬

O(n log n)이면 버블정렬같은거 못씀. 연결리스트에 대해서 정렬하는건 만들어야함.

### 어프로치

병합정렬의 핵심은 분할정복이다. 연결리스트의 중앙을 찾고 분할해야하기 때문에, 중앙찾기에 적합한 러너를 쓰자.

1. 러너 관련 로직
   1. `half, slow, fast` 러너 변수 생성
   2. half는 slow의 당시 주소값을 참조, slow 는 한칸씩, fast는 두칸씩
   3. fast와 fast.next가 None일 때 까지 계속 간다.
   4. half.next는 의미없으므로 None으로 처리
2. 첫번째(half), 중간(slow)를 sort하는 함수에 재귀로 처리
3. 머지도 재귀.
   1. l1 다음엔 l2를 붙이도록 비교문을 넣고 스왑도 해준다.
   2. `l1` or `l2` 가 있는데, 이는 `l1`에 값이 있으면 항상 `l1`을, `l1`이 `None`이면 `l2`를 리턴한다. 라는 뜻이다.

# Q59) 구간 병합

문제) 겹치는 구간을 병합하시오

Input)

```
[[1, 3], [2, 6], [8, 10], [15, 18]]
```

Output)

```
[[1, 6], [8, 10], [15, 18]]
```

설명)

```
[1, 3]과 [2, 6]의 범위가 겹치므로 [1, 6]이 된다.
```

## A1) 정렬 후 병합하기

### 어프로치

정렬 순서는 첫 번째 값을 기준으로 한다.

1. 첫번째 값을 키로 이용하여 정렬한다. 정렬한 값을 가지고 반복문을 돌린다.
2. 현재 시작 아이템이 이전 아이템의 끝과 겹친다면 최댓값 기준으로 병합한다.
   1. 다음 시작값이 현재 끝하고 안겹치면 `merged += [i, ]` 로직으로 새 아이템을 추가한다.

# Q60) 삽입 정렬 리스트

문제) 연결 리스트를 삽입 정렬로 정렬하시오.

## A1) 삽입 정렬 쓰기

1. 정렬 해야 할 대상(`head`), 정렬을 끝낸 대상(`cur`)인 두 그룹으로 나눈다.
2. `cur.next` 가 있으면서, `cur.next.val < head.val` 이면 `cur = cur.next` 로 이어간다.
3. `cur = parent` 라고 쓰면서 다시 처음부터 삽입정렬을 수행한다.

맨 마지막에는 `cur.next` , 즉 정렬완료된 값을 리턴한다.

# Q61) 가장 큰 수

문제) 항목들을 조합하여 만들 수 있는 가장 큰 수를 출력하시오.

예제1 Input)

```
[10, 2]
```

예제1 Output)

```
"210"
```

예제2 Input)

```
[3, 30, 34, 5, 9]
```

예제2 Output)

```
"9534330"
```

## A1) 삽입 정렬

### 어프로치

1. 맨 앞에서부터 자릿수단위로 비교하여 크기 순으로 정렬.
   1. `9` 는 `30` 보다 앞자리 수가 더 크니까 앞으로.
   2. `930` 이 큰가? `309` 가 큰가?를 비교
2.

# Q62) 유효한 애너그램

문제) t가 s의 애너그램인지 판별하시오.

예제1 Input)

```
s = "anagram", t = "nagaram"
```

예제1 Output)

```
True
```

예제2 Input)

```
s = "rat", t = "car"
```

예제2 Output)

```
False
```

## A1) 정렬을 이용한 비교

걍 두 값 "정렬" 하고 똑같은지만 보면 그만.

# Q63) 색 정렬

빨간색을 `0`, 흰색을 `1`, 파란색을 `2`라 할 때, 순서대로 인접하는 제자리(in-place) 정렬을 하시오

Input)

```
[2, 0, 2, 1, 1, 0]
```

Output)

```
[0, 0, 1, 1, 2, 2]
```

## A1) Dutch National Flag Problem

국기별로 피벗을 나누고 피벗보다... 작은값/같은값/큰값 으로 분할한다.

### 어프로치

퀵정렬 개선판임.

i, k가 양쪽포인터이고, j가 이동하면서 mid 값을 기준으로 swap 하는 모양새다.

# Q64) 원점에 K번째로 가까운 점

평면상에 points 목록이 있을 때, 원점 (0, 0)에서 K번 가까운 점 목록을 순서대로 출력하라. 평면상 두 점의 거리는 유클리드 거리로 한다.

예제 1 Input)

```
points = [[1, 3], [-2, 2]], K = 1
```

예제 1 output)

```
[[-2, 2]]
```

(1, 3)과의 거리는 sqrt(10) 이고, (-2, 2)와의 거리는 sqrt(8) 이다. 두 번째가 더 가까우며, `K = 1`로 가장 가까운 거리 K개는 `[[-2, 2]]`이다.

예제 2 input)

```
points = [[3, 3], [5, -1], [-2, 4]], K = 2
```

예제 2 output)

```
[[3, 3], [-2, 4]]
```

가장 가까운 거리 K=2 개는 `[[3, 3], [-2, 4]]` 개이다.

## A1) 유클리드 거리의 우선순위 큐 순서

유클리드 공간에서 두 점사이의 거리를 구하는 일반적인 방법을 수식으로 표현하고 이 값을 작은 순으로 k 번 추출한다. -> k 번 추출에서 우선순위 큐를 떠올린다.

우선순위 큐는 힙으로 구현한다.

좌표값을 다 꺼내고 거리 계산 후, (dist, x, y) 순으로 넣고 min heap 에 넣고 처리하면 깔끔.

만약 먼 거리별 값을 구해야하면 max heap을 생각할 수도 있지만 음수로 변환해서 `-dist` 로 처리하는 생각을 하기.
