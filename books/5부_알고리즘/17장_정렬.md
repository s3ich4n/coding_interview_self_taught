# 정렬

정렬 알고리즘: 값을 순서대로 넣는 알고리즘. 숫자식순서/사전식순서대로 정렬하는게 맞음.

빅오, 분할정복, 힙, 이진트리, 시간/공간의 트레이드오프 등을 다 다룸.

---

버블소트 하나 즉석에서 말 못한다고 일 못하는 사람 아니지만서도, 이걸 공부하는거는 일리있다. 대학교때 그 고생을 한걸 생각해보자. 그런 방법에 대해 학습한거다.

## 버블 정렬(Bubble Sort)

n번의 라운드를 O(n)만큼 살펴본다. 그래서 O(n^2) 다.

## 병합 정렬 (Merge Sort)

divide and conquer의 대표주자 `theta(n log n)` 이며, 안정 정렬이다. 

못 쪼갤 때 까지 계속 분할하고, 분할한 이후 그걸 다시 정렬한다.

cf. 퀵 소트의 최악의 수는 O(n^2) 이고, 이는 정렬되어있거나, 역순정렬이 이미 된 값에 대해 수행할 때의 최악의 케이스다.

## 퀵 정렬 (Quick Sort)

피벗을 기준으로 좌우를 나눈다(파티션 교환 정렬임, Partition-Exchange Sort). pivot 보다 작으면 왼쪽, 크면 오른쪽으로...

로무토란 사람이 만든 파티션 계획을 살펴보자.

1. 항상 맨 오른쪽의 피벗을 택한다.
   1. 간결하고 이해하기는 쉽다. 아마 대학교 때도 그걸로 구현했을걸



## 안정 정렬 vs. 불안정 정렬

정렬된 것을 다시 정렬할 때 엉망이 되면 불안정 정렬

정렬한걸 재정렬해도 되면 안정 정렬

불안정 정렬의 예시: 퀵 정렬

안정 정렬의 예시: 병합 정렬

파이썬은 기본적으로 병합정렬, [삽입정렬](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)을 휴리스틱하게 조합한 팀소트를 쓴다.

# Q58) 리스트 정렬

문제) 연결리스트를 O(n log n) 에 정렬하시오.

Input)

```
4->2->1->3
```

Output)

```
1->2->3->4
```

## A1) 병합정렬

 O(n log n)이면 버블정렬같은거 못씀. 연결리스트에 대해서 정렬하는건 만들어야함.

### 어프로치

병합정렬의 핵심은 분할정복이다. 연결리스트의 중앙을 찾고 분할해야하기 때문에, 중앙찾기에 적합한 러너를 쓰자.

1. 러너 관련 로직
   1. `half, slow, fast` 러너 변수 생성
   2. half는 slow의 당시 주소값을 참조, slow 는 한칸씩, fast는 두칸씩
   3. fast와 fast.next가 None일 때 까지 계속 간다.
   4. half.next는 의미없으므로 None으로 처리
2. 첫번째(half), 중간(slow)를 sort하는 함수에 재귀로 처리
3. 머지도 재귀.
   1. l1 다음엔 l2를 붙이도록 비교문을 넣고 스왑도 해준다. 
   2. `l1` or `l2` 가 있는데, 이는 `l1`에 값이 있으면 항상 `l1`을, `l1`이 `None`이면 `l2`를 리턴한다. 라는 뜻이다.



# Q59) 구간 병합

문제) 겹치는 구간을 병합하시오

Input)

```
[[1, 3], [2, 6], [8, 10], [15, 18]]
```

Output)

```
[[1, 6], [8, 10], [15, 18]]
```

설명)

```
[1, 3]과 [2, 6]의 범위가 겹치므로 [1, 6]이 된다.
```



## A1) 정렬 후 병합하기

### 어프로치

정렬 순서는 첫 번째 값을 기준으로 한다.

1. 첫번째 값을 키로 이용하여 정렬한다. 정렬한 값을 가지고 반복문을 돌린다.
2. 현재 시작 아이템이 이전 아이템의 끝과 겹친다면 최댓값 기준으로 병합한다.
   1. 다음 시작값이 현재 끝하고 안겹치면 `merged += [i, ]` 로직으로 새 아이템을 추가한다.

# Q60) 삽입 정렬 리스트

문제) 연결 리스트를 삽입 정렬로 정렬하시오.

## A1) 삽입 정렬 쓰기

1. 정렬 해야 할 대상(`head`), 정렬을 끝낸 대상(`cur`)인 두 그룹으로 나눈다.
2. `cur.next` 가 있으면서, `cur.next.val < head.val` 이면 `cur = cur.next` 로 이어간다.
3. `cur = parent` 라고 쓰면서 다시 처음부터 삽입정렬을 수행한다.

맨 마지막에는 `cur.next` ,  즉 정렬완료된 값을 리턴한다.

# Q61) 가장 큰 수

문제) 항목들을 조합하여 만들 수 있는 가장 큰 수를 출력하시오.

예제1 Input)

```
[10, 2]
```

예제1 Output)

```
"210"
```

예제2 Input)

```
[3, 30, 34, 5, 9]
```

예제2 Output)

```
"9534330"
```

## A1) 삽입 정렬

### 어프로치

1. 맨 앞에서부터 자릿수단위로 비교하여 크기 순으로 정렬.
   1. `9` 는 `30` 보다 앞자리 수가 더 크니까 앞으로.
   2. `930` 이 큰가? `309` 가 큰가?를 비교
2. 