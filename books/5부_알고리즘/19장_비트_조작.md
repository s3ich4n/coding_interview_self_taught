# 비트 조작

클로드 섀넌으로부터 boolean algebra가 회로에 적용되고 논리 게이트가 만들어졌다. 이것은 현대 컴퓨터의 기본 중 기본이다. 비트 조작 기법은 하드웨어 뿐 아니라 다양한 부분에 널리 쓰인다.

## 부울 연산자

AND OR NOT 이 그 얘기임.

파이썬에선 `and`, `or`, `not` 으로 쓸 수 있다.

XOR은 보조 연산자로, 되게 특이하고 매우 중요함. 서로 다른 값이 들어와야 참임. (다른 연산으로 만들어냄)

## 비트 연산자

비트 연산자는 위의 부울 연산자를 사용하는 다른 방안이다.

- `&`: and
- `|`: or
- `^`: xor
- `~`: not

신기한 점

```python
>>> ~ True
-2
```

NOT은 2의 보수에서 1을 뺀 값이다. 십진수로 표현하면 `NOT x = -x - 1`이다.

## 비트 조작

덧셈뺄셈은 직관적이라 생략

### 곱셈

곱셈은 곱할 값에서 자리수만큼 시프팅한 결과를 더하는 것과 같다.

`bin(0b0011 * 0b0101)` 은 사실 `bin(0b0011 + 0b001100)` 과 같다.

### 시프팅

시프팅도 마찬가지. 그냥 비트를 밀어내고 `0`을 넣는다. 2배씩 곱하고 2배씩 나누는 식이다.

### not연산과 xor?

`bin(0b0101 ^ ~0b1100)` 은?

NOT 연산하면 음수처리되기 때문에 컴퓨터가 생각하는 식의 내용이 나옴.

따라서 원하는 연산을 하려면?

1. 자리수만큼의 비트마스크 생성
2. 1의 값과 XOR 후, 그 결과를 XOR

```python
MASK = 0b1111
bin(0b0101 ^ (0b1100 ^ MASK))
```

를 해야됨

파이썬 진법 표현은 `bin()`, `int()`, `hex()` 로 쓴다.

2진수 변수는 `0b` 로 시작하고 16진수 변수는 `0x` 로 시작한다.

## 2의 보수

2의 보수 범위는 다음과 같다. 너무 뻔해서 그냥 외우자.

`-2^(n-1) < x < 2^(n-1) -1`

### 파이썬에서의 2의 보수?

CPython 구현체는 내부적으로 임의 정밀도(Arbitrary-Precision)를 지원한다.

1. 부호는 별도 필드로 가진다
2. 비트 연산이 필요할 때만 2의 보수로 변환한다.

### 2의 보수 수학연산

숫자 포맷에서의 2의 보수와, 연산일 때의 2의 보수는 다르다.

연산일 때의 2의 보수 수학 연산: Additive Inverse Operation (양수-음수, 음수-양수) 변환 연산 ... `NOT` 처리 후 `+1`함.

- 비트 연산자 NOT은 2의 보수에서 1을 뺀 것
- 2의 보수 수학 연산은 상기 NOT에서 1을 더한것

비트 수가 정해져있을 때 얼마만큼 비트연산을 할 것인지 생각해놓으시오

### 비트 연산자 `NOT`

기준 비트에서 0과 1을 딱 바꾼다.

몇비트 연산을 할건지 가정한다면 그 값에 맞게 연산해야함을 기억하라.

양수-음수 개념을 비트개념 넣고 처리할 때 전제(1로 시작하는 값은 음수)가 안맞으면 연산이 모두 틀어진다.

비트값은 문제 제한 혹은 상황에 맞게 여유롭게 잡고 작업하라.

# Q70) 싱글넘버

딱 하나를 제외하고 모든 엘리먼트는 2개씩 있다. 1개인 엘리먼트를 찾아라.

예제 1 Input)

```
[2, 2, 1]
```

예제 1 Output)

```
1
```

예제 2 Input)

```
[4, 1, 2, 1, 2]
```

예제 2 Output)

```
4
```

## A1) XOR 풀이

두 번 등장한 엘리먼트는 0으로 초기화되고 한번만 등장한 엘리먼트는 그 값을 온전히 보존한다.

모든 값을 XOR하면 그 한 값만 남는다.

# Q71) 해밍 거리

두 정수를 입력받아 몇 비트가 다른지 계산하시오

Input)

```
x = 1, y = 4
```

Output)

```
2
```

설명

```
1   (0 0 0 1)
4   (0 1 0 0)
       *   *
```

`*`가 있는 두 비트가 다르다. 정답은 `2`

## A1) XOR 풀이

NLP에도 널리 쓰이는 해밍거리(Hamming Distance)는 두 정수, 두 문자열의 차이를 의미한다.

문자열의 해밍 거리는 다른 자리의 문자갯수를 의미한다.

이진수에서는 다른 위치의 비트갯수를 의미한다.

XOR 후 `1` 나온 값을 세면 그만이다.

# Q72) 두 정수의 합

두 정수 a와 b의 합을 구하시오. `+`, `-` 없이 구현하시오.

예제 1 Input)

```
a = 1
b = 2
```

예제 1 Output)

```
3
```

예제 2 Input)

```
a = -2
b = 3
```

예제 1 Output)

```
1
```

## A1) Full Adder 구현

### 어프로치

전처리 이후 더한다.

### 전처리

a, b, cin 값을 넣고 sum, cout 값을 토대로 결과를 리턴한다.

이 때, 중간값을 Q1, Q2, Q3로 두고 이를 각각 이 값으로 생각하자.

```
q1 = a & b
q2 = a ^ b
q3 = cin & q2
```

논리회로를 가지고 연산을 그대로 처리해보자.

```
cout = q1 | q3
sum = cin ^ q2
```

아까전에 MASKING 값이 필요하다고 했다.

문제에서 값의 제한이 없으므로 일단 32바이트짜리로 두고 생각하자.

```
MASK = 0xffffffff
a_bin = bin(a & MASK)[2:].zfill(32)
```

바이너리 연산을 하면 `0b` 가 붙으니 그걸 뗀 문자열을 만든다. 이후 `zfill` 을 사용하여 값을 넣는다.

전처리 끝.

### 연산 (1)

가장 낮은 값부터 높은 값 까지 더한다. 마지막 캐리값은 없어진다.

result 를 낮은 자릿수부터 채웠으니까 이를 뒤집고 십진수 정수로 바꾼다. 마스킹 후 자릿수를 초과한 값을 처리한다.

### 연산 (2) 음수 처리

32비트 양의정수 최대값은 `0x7FFF FFFF` 이다.

32번째 비트가 1이면 이보다 큰 값이다. 이 경우 마스킹값과 XOR 후 NOT 처리를 해서 다시 음수로 만든다.

```python
INT_MAX = 0x7FFFFFFF

...
if result > INT_MAX:
    result = ~(result ^ MAX)    # 위에서 설명한 음수처리
```

## A2) 간략화

핵심로직을 a, b값 그대로 쓰고 overwrite 후 자릿수만 처리해주는 것으로 끝.

# Q73) UTF-8 검증

입력값이 UTF-8 문자열이 맞는지 검증하시오.

예제 1)

```
data = [197, 130, 1]
```

이 값은 `11000101 10000010 00000001` 이다. 2바이트 문자 다음에 오는 1바이트 문자다. 모두 2개며 정상이다.

예제 2)

```
data = [235, 140, 4]
```

이 값은 `11101011 10001100 00000100` 이다. 첫 바이트의 첫 3비트가 모두 1이고 4번째 비트가 0이다. 이는 3바이트 문자열이다.

다음 바이트도 10으로 시작해서 정상이다.

그 다음 바이트는 10으로 시작하지 않는다. 따라서 비정상이다.

## A1) 첫 바이트를 기준으로 한 판별

인코딩 구조는 아래와 같다

### UTF-8 바이트 순서의 이진 포맷

| 바이트 수 | 바이트 1  | 바이트 2  | 바이트 3  | 바이트 4  |
| --------- | --------- | --------- | --------- | --------- |
| 1         | 0xxx xxxx |           |           |           |
| 2         | 110x xxxx | 10xx xxxx |           |           |
| 3         | 1110 xxxx | 10xx xxxx | 10xx xxxx |           |
| 4         | 1111 0xxx | 10xx xxxx | 10xx xxxx | 10xx xxxx |

첫 바이트수가 뭔지에 따라 검증하는게 핵심이다.

나머지는 로직을 풀어내면 된다.

# Q74) 1비트의 갯수

unsigned integer를 받고 1비트의 개수를 출력하시오.

예제 1 Input)

```
00000000000000000000000000001011
```

예제 1 Output)

```
3
```

예제 2 Input)

```
00000000000000000000000010000000
```

예제 2 output)

```
1
```

## A1) `1`의 갯수 계산

해밍거리로 마저 체크하면 됨

`0`이 아닌걸 체크하는거니까 `0`과 xor하면 아닌 값들을 캐치할 수 있다.

```python
def count_of_1(n: int) -> int:
    # 비트의 전체 길이에 맞추자.
    # return bin(n ^ 00000000000000000000000000000000).count('1')

    # 사실 하나만 둬도 됨.
    # return bin(n ^ 0).count('1')

    # 사실 0은 생략 가능.
    return bin(n).count('1')
```

## A2) 비트 연산

범용적인 알고리즘을 생각해보면...

이진수의 특징을 살펴보자.

- `1000`에서 `1`을 빼면 `0111`.
- 두 값을 AND 하면 `0`

1을 뺀값과 AND 연산을 하면 기존 수의 비트 플래그가 `1`인 값이 빠지는 특징이 있다.

따라서 `0`이 될 때 까지 이를 반복하고, 연산을 몇번 했는지 세면 1비트의 갯수가 된다.

# 번외

XOR로 변수 스왑

```
x, y = 9, 4
x = x^y
y = x^y
x = x^y
x, y
```
