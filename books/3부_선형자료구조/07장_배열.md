# 배열

메모리 공간을 이어서 쓰느냐 (contiguous), 포인터 기반의 연결 (link) 방식이냐에 따라 달라짐. 연결방식의 ADT는 흔히 아는 linked list이다.

포인터? 메모리 영역을 1바이트 단위로 가리키는 주소. 32비트 머신은 2^32, 62비트 머신은 2^64까지 가리킬 수 있음.

요즘 프로그래밍 언어의 배열은 동적 배열으로 사용가능(리사이징을 알아서 해줌). 파이썬은 [`listobject.c`](https://github.com/python/cpython/blob/594de165bf2f21d6b28eb17003ea78fc20c0ffed/Objects/listobject.c#L60-L70) 에 있음.

초기값은 작게잡고 점차적으로 늘림. 참고로, 파이썬의 그로스 팩터(growth factor, 성장 인자)는 초기 `2`배, 후에 `1.125`배

```C
// The growth pattern is:  0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ...
new_allocated = ((size_t)newsize + (newsize >> 3) + 6) & ~(size_t)3;
```

자바 `ArrayList`는 `1.5`배, C++의 `std::vector`, Ruby는 그냥 `2`배

용량 차면 전부 복사하고 새로 늘리는데, 자주 일어나진 않음. 분할 상환 분석에 따른 입력 시간(Amortized Insertion Time)은 여전히 O(1).

# Q7) 두 수의 합

문제) 덧셈하여 타겟을 만들 수 있는 배열의 **두 숫자 인덱스**를 리턴하시오.

Input)

```
nums = [2, 7, 11, 15], target = 9
```

Output)

```
[0, 1]
```

description)

```
nums[0] + nums[1] = 2 + 7 = 9
```

## A1) Brute force

배열 2번 반복하며 모든 조합을 더하고, 일일이 확인한다. O(n^2)이니, 최적화가 필요하다.

## A2) `in` 을 이용한 탐색

모든 조합을 비교하지 않음. 타겟에서 첫 번째 값을 뺀 `target - n` 이 존재하는지 탐색한다면? 

왜냐면, `target - n ` 한 값이, 다른 배열 다 더한거에서 있는지를 브루트 포스 하는 방법이다.

시간복잡도: A2도 O(n) 루프 안에서 `in`을 썼으니 O(n) 연산을 한번 더 한다. `in` 키워드를 쓰면 파이썬에서 더 빠르게 처리된다.

## A3) 첫번 째 수를 뺀 결과 키 조회

비교나 탐색 대신, 한 번에 정답찾는 방법?

### 어프로치:

1. `k, v`쌍으로 숫자를 바꾸고 딕셔너리에 저장
2. 타겟에서 첫 번째 수를 뺀 결과를 키로 조회

`enumerate()` 과 딕셔너리의 특징을 잘 살려서 빠른 연산을 가능하게 했다!

## A4) 조회구조 개선

for문 두개쓰지 말고 하나만 쓴다면?

### 어프로치:

1. 전체를 굳이 저장하지 않는다 (메모리 사용량 개선)
2. 매번 비교하는 로직은 변함이 없다. → 성능상의 이점은 없다.

## A5) 투포인터?

* 왼쪽 포인터와 오른쪽 포인터의 합이 타겟보다 크면 오른쪽 포인터를 왼쪽으로
* 작다면 왼쪽 포인터를 오른쪽으로

그런데 이건 정렬된 시퀀스에서만 가능. 하지만 문제는 **정렬 안 된 그냥 시퀀스**에서의 인덱스를 찾기 어려움.

### lessons learned:

* 문제를 오독하지 말자! → 뭘 원하는지 캐치하고 그거대로 푸는게 좋을 듯 하다.

# Q8) 빗물 트래핑

문제) 높이를 입력받고, 비가 내린 후 얼마나 많은 물이 쌓일 수 있는지 계산하시오.

Input)

```
[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
```

Output)

```
6
```

## 답 찾기 어프로치

1. 높이와 너비를 모두 살펴보면 O(n^2) 로 나올 것이다. → O(n^2)니까 개선의 여지가 있다. 아니, 해야된다.

## A1) 투 포인터 이동

### 어프로치

1. 투 포인터를 맨 왼쪽에서, 오른쪽으로 하나씩 좁혀가며 **가장 높은 막대를 찾기**
2. `volume += left_max - height[left]`
   `volume += right_max - height[right]`
   을 통해서 최대 높이의 막대까지 각 좌우 기둥 최대의 높이인 `left_max`, `right_max` 가 **현재 높이와의 차이만큼** 물 높이 volume을 더해 나감

### 이해한 핵심

1. 낮은 쪽은 `좌우 기둥의 최대높이 - 자신의 현재 높이`만큼 물이 찬다.
2. 최대 지점을 향해 두 포인터가 "동시에" 찾아간다 → 투 포인터가 함께 움직여서 O(n) 만에 조회할 수 있다.

## A2) 스택 쌓기를 통한 해결

### 어프로치

1. 현재 높이가 이전높이보다 높을 때, 즉 꺾이는 부분의 **변곡점(Inflection Point)**을 기준으로 격차만큼 물 높이(`volume`)을 채운다. 
2. 스택으로 계속 채우다가 변곡점을 만날 때(양의 정수만큼의 기울기가 생기는 경우임!)마다 스택에서 하나씩 꺼내면서 이전과의 차이만큼 물 높이를 채워나간다.
3. 변곡점내의 반복문으로 인해 O(n) 이지만, 스택으로 전체 높이를 한 번 만에 살펴볼 수 있으므로 O(n) 이다. 이 정도면 좋지.

### 이해한 핵심

* 곡선이 변하는 지점 부터 격차만큼 물을 채운다가 핵심이다.
* 다만 그 여러 변곡점을 계산하는게 스택에 담겨있을 뿐이다.
* 프로그램을 돌려보며 복습하면, 변곡점을 만나고 스택을 pop 하면서 진행하는 과정이 이해될 것이다.

# Q9) 세 수의 합

문제) 배열을 입력받아 합으로 `0`을 만들 수 있는 `3`개의 엘리먼트를 출력하시오.

Input)

```
nums = [-1, 0, 1, 2, -1, 4]
```

Output)

```
[
	[-1, 0, 1],
	[-1, -1, 2],
]
```

## A1) 브루트포스?

O(n^3)으로 어림잡히는데, O(n^2) 정도로 줄이기를 원하는 것이 문제의 의도로 보인다.

### 어프로치

#### 사전분석

엘리먼트를 구하기만 하면 되므로, 임의로 정렬해도 되는 것으로 보인다. (output의 `[-1, -1, 2]` 리스트를 보니 그런 것 같다.)

#### 정렬

`nums.sort()` 하면 O(n log n)에 정렬된다. 이 후에 문제는,

i, j, k에 대해 포인터가 움직이면서 `i + j + k = 0` 을 찾으면 된다.

그런데, 여기에서는 **중복된 값이 있을 수 있다.** 이에 대한 예외처리를 진행하고 코드를 작성하도록 한다.

## A2) 투 포인터

`i` 를 축으로 하고, 중복된 값을 건너뛰는것은 위와 동일.

`['-4', '-1', '-1', 0, 1, 2]` 에서 `-1`부터 `2`까지 인덱스를 `2`개 뒤로 해서 나머지 변수값과 `i` 값의 합이 0인지 "투 포인터"로 검사한다.

### 어프로치

투 포인터가 간격을 좁히며 sum을 계산

* 0보다 작으면? 값을 키워야 하므로 `left` 를 한칸 우측으로 옮김
* 0보다 크면? 값을 작게해야 하므로 `right`를 한칸 좌측으로 옮김
* 서로 교차할 때 까지 찾음.
* 만일 찾으면, `left`, `right` 모두 한칸씩 움직임
  * 이 때, **자신의 "뒷값" 과 중복**되지 않는지 점검하는 로직을 넣어야함.

## 잠깐) 투포인터란?

**정렬된** 값을 대상으로, 두개의 포인터가 좌우로 움직이며 문제를 풀이하는 방법. 슬라이딩 윈도우와 흡사함.

# Q10) 배열 파티션 I

문제) `n`개의 페어(한 쌍)를 이용한 `min(a, b)` 의 합으로 만들 수 있는 가장 큰 수를 출력하시오.

Input)

```
[1, 4, 3, 2]
```

Output)

```
4
```

설명)

`n` 은 2가 되며, 최대 합은 4이다.

```
min(1, 2) + min(3, 4) = 4
```

## 해결 접근

1. 페어의 `min()` 을 합산했을 때 최대(Argmax) 를 만드는 것은, `min()` 이 되도록 커야한다는 뜻이다.
2. 뒤에서부터 내림차순으로 집어넣으면 항상 최대 `min()` 페어를 유지할 수 있다.
3. 배열 입력값은 `2n` 개일 것이다. 앞에서부터 오름차순으로 집어넣어도 결과는 같을 것이다.

배열은 3C2개가 나오겠다.

* min(A1, A2), min(A3, A4)
* min(A1, A3), min(A2, A4)
* min(A1, A4), min(A2, A3)

위의 조합으로 가장 큰 수를 찾으라는 내용이긴 한데, **특징이 있다!**

오름차순을 하면, 앞에있는 값이 항상 "작다" 그리고, 짝수번째 값이 항상 "작다".

## A1) 오름차순 풀이

정렬해서 `min(1, 2) + min(3, 4)` 를 하면 큰값이 나온다.

## A2) 짝수 번째 값 계산

어차피 그럴거면 0포함 짝수번째 값만(0, 1, 2, 3으로 시작한다!) 더하는게 낫잖느냐.

## A3) Pythonic way

`return sum(sorted(nums)[::2])` 짝수번째 값의 합을 리턴. 오.....

# Q11) 자신을 제외한 배열의 곱

문제) 배열을 입력받아 `output[i]` 가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하세요.

Input)

```
[1, 2, 3, 4]
```

Output)

```
[24, 12, 8, 6]
```

제약사항)

```
나눗셈을 하지 말고, O(n) 에 풀이하시오.
```

## 해결 접근

다 곱해놓고 자기자신을 나누는 식의 접근을 하면 오답처리!

풀이는 단 하나뿐이라는데, 이는 자기 자신을 제외하고 왼쪽의 곱셈결과와 오른쪽의 곱셈결과를 모두 곱하면 된다.

여기서는 `range(x, y, z)` 에서 z가 -1이면 뒤로 카운트 하는 어프로치를 소개한다.

# Q12) 주식을 사고 팔기 가장 좋은 시점

문제) 한 번의 거래로 낼 수 있는 최대 이익을 산출하시오.

Input)

```
[7, 1, 5, 3, 6, 4]
```

Output)

```
5
```

설명)

* 1일 때 사서 6일 때 팔면 5의 이득을 얻음

## A1) 브루트 포스?

처음부터 전부다 언제 사서 언제 팔고를 무한반복하면... **타임아웃**

* `max_price` 라고 하여, 최대값을 이 변수에 저장하자.
* `i`, `j` 번째의 값을 가지고 루프를 돈 후, `max_price` 는 `max(prices[j] - price, max_price)` 인지로 계산.

## A2) 저점과 현재값과의 차이 계산

### 어프로치

1. 값을 좌표상에 세워서 시각화한 후 생각해보자.
   1. 인덱스 1이 저점, 인덱스 4가 고점이다.
   2. 현재값을 가리키는 포인터가 저점을 찾는다
   3. 이후 생긴 고점과의 차를 계속해서 저장한다(덮어쓰면서)!
2. 그러면 O(n) 만에 될 것으로 보인다.

그렇다면 최대값, 최소값을 잡자.

`profit = -sys.maxsize` (오?)
`min_price = sys.maxsize` (오)

### Tips

1. 이런 숫자는 시스템에서의 최소값 최대값을 잡으면 문제가 없다. 빈 입력값의 경우에 대한 케이스일 때는 `-sys.maxsize` 가 그대로 나올 수도 있으니, `profit = 0` 으로 바꾸면 된다.
2. 어떤 문제는 최소값 최대값을 정해주므로, 그 값에 맞추어주면 된다.

