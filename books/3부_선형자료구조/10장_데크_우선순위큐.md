# 데크

Double-ended Queue. 양쪽끝에서 넣고빼고가 된다.

`collections.deque` 를 씁시다.

CPython 구현체 기준, 하위배열을 지닌 이중 연결리스트로 구현되어 있다. [자세한건 여기를...](https://github.com/python/cpython/blob/e3a3863cb9561705d3dd59a9367427ed45dfb5ea/Modules/_collectionsmodule.c#L78-L95)

1. 왼쪽링크, 데이터, 오른쪽링크를 가리킬 수 있다
   1. 왼쪽링크/오른쪽링크에 대한 `BLOCK` 포인터 주소값을 가리킨다.
   2. 인덱스도 저장해두었다
   3. 최대길이도 저장했다. (파이썬에서는 참고로 유도리있게 늘어납니다)

# Q26) 원형 데크 디자인

다음 연산을 제공하는 원형 데크를 디자인하시오.

1. `k` 사이즈의 원형 데크를 만들라
2. 앞뒤로 추가제거를 하라
3. 앞뒤 아이템을 꺼내라
4. 데크가 비어있는지/꽉찼는지 판단하라

코드 참고.

---

# 우선순위 큐

큐/스택같은 ADT와 유사하지만, '우선순위'와 연관되어있다. 다익스트라 알고리즘, 힙 등과 연관있으니... 꼭 봐야한다. 개념을 잡고 바로 넘어가야함.

# Q27) `k` 개 정렬 리스트 병합

문제) `k`개의 정렬된 리스트를 1개의 정렬된 리스트로 병합하시오.

Input)

```
[
	1->4->5,
	1->3->4,
	2->6,
]
```

Output)

```
1->1->2->3->4->4->5->6]
```

## A1) `heapq`를 써서 해결

### 어프로치

* `heapq` 를 써서, 우선순위 큐에 넣고 이를 해결한다.
* 파이썬의 `heapq`는 min heap 이다.

Input을 넣고, 각 `ListNode`의 루트를 힙에 저장한다. 각 리스트 별 `lst.val` 값을 꺼낼 `<` 연산자가 정의되지 않으므로, 해당값을 처리하기위해, Input의 리스트 추가 순서값을 `.heappush()` 함수로 넣어버려서 해결하자.

그 후 `while heap` 루프를 통해, `result` 값에는 min heap으로 나온 값을 계속 next로 이어주고, 나머지 값은 다시 `heappush()` 를 통해 heap 에 넣는다. 그 다음 `heappop()` 을 선언하면, 순서에 맞는 값이 알아서 나오게 된다. 그런고로, heap 이라는 값이 빌 때 까지 무한루프를 돌리면 뺐다 넣었다를 반복하며 알아서 정렬된다. 이것이 핵심.

