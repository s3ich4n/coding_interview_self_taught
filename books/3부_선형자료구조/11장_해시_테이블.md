# 해시 테이블

> 연관 배열 ADT를 구현하는 자료구조. 이는 키를 값에 매핑할 수 있는 구조를 의미함.

시간 복잡도가 `O(1)` 인게 매우 사기다. 다만 그만큼 메모리를 퍼먹는다.

## 해시

> 임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용할 수 있는 함수

해시 테이블을 인덱싱하기 위해 해시 함수를 쓰는 것을 해싱(Hashing) 이라고 한다. 해싱은 정보를 빠르게 저장하고 검색하기위한 기법이다. 심볼 테이블을 구현할 때도 적합하다. 체크썸, 손실압축, 무작위화 함수, 암호와도 관련이 있다. 어디어디에 관련있고 쓰인다고 말은 했지만, 각 영역에 맞게 다르게 설계되고 최적화됨에 유의한다.

성능좋은 해시함수들은 이런 특징을 가진다:

- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시값이 균일하게 분포
- 사용할 키의 모든 정보를 이용하여 해싱
- 해시 테이블 사용 효율이 좋아야 함

### 생일 문제

해시 충돌은 얼마나 자주 생길까? **생각보다 충돌은 쉽게 일어난다.** 예를들어 생일은 23명만 모여도 겹칠 확률이 50%나 된다. (Birthday Problem)

### 비둘기집 원리

> `n` 개의 아이템을 `m` 개의 컨테이너에 넣을 때, `n>m`이면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어있다.

E.g., 9개의 비둘기 집에 10마리의 비둘기가 들어오려면...? 최소 한번 이상은 충돌한다..! 여러번 충돌하면 연산이 많아진다는 뜻이므로, 충돌을 최소화할 필요가 있다.

### 로드 팩터(Load Factor)

> 해시 테이블에 저장된 데이터 개수 `n` 을 버킷의 개수 `k` 로 나눈것을 의미

로드팩터 비율은 해시 테이블의 크기를 조정하는데 쓰인다. 또한 이 값은 해시 함수가 키들을 잘 분산시켜주는지의 척도로 사용할 수도 있다. Java 10의 `HashMap` 의 Default Load Factor 값은 `0.75` 이다. 시간과 공간 비용의 적절한 절충안이라고 한다. 일반적으로 로드팩터가 크면 테이블의 성능이 떨어진다. Java 10의 `HashMap` 은 로드 팩터가 `0.75` 를 넘으면 해시 테이블의 공간을 재할당한다.

### 해시 함수

키가 해시로 변하는데 쓰이는 함수를 의미한다. 최상의 분포는 데이터에 따라 다르다. 쉽고 널리 쓰이는 방식은 모듈로 연산을 이용한 나눗셈 방식(Modulo-Division Method)을 의미한다.

> `h(x) = x mod m`

단, `h(x) `는 입력값 `x` 의 해시함수를 통해 생성된 결과. `m` 은 해시 테이블의 크기(2의 멱수에 가깝지 않은 소수를 선택하는 것이 좋음).

Effective Java의 저자는 값 x를 정하며, `31` 로 하는 거듭제곱 P(31)의 연산으로 정했다고 한다. 메르센 소수이므로, 수학적으로도 좋다고 한다.

## 충돌

해시 충돌은 피할 수 없다. 충돌이 발생하면 어떻게 회피하는가?

### 개별 체이닝

충돌 발생 시, 충돌발생한 값을 연결 리스트로 잇는다. 이는 아래와 같은 원리를 가진다.

1. 키의 해시값을 계산
2. 해시 값을 이용하여 배열의 인덱스를 구함
3. 같은 인덱스가 있다면 연결 리스트로 연결

Java 8에서는 이 연결리스트 구조를 레드-블랙 트리에 저장하여 사용했다.

### 오픈 어드레싱

충돌 발생 시, 탐사를 통해 빈 공간을 찾아나서는 방식. 전체 슬롯 갯수 이상은 저장할 수 없다. 충돌이 일어나면 모든 공간에서 탐사 후 빈 공간을 찾아 해결한다. 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다.

하지만 이 방법은 데이터가 일정 영역에 겹쳐서 계속 생기는 클러스터링의 원인이 될 수 있다. 그리고 클러스터가 점점 커지면 인근 클러스터와 겹칠 수도 있다. 이러면 특정 위치에는 데이터가 몰리고, 특정 위치에는 데이터가 거의 없을 수 있으며, 이는 탐사 시간 증가/해싱 효율 감소의 원인이 된다.

오픈 어드레싱 방식은 버킷 사이즈보다 크게 넣을 수 없고, 로드팩터 비율이 넘어서면 그로스 팩터 비율에 따라 더 큰 크기의 버킷 생성 후, 리해싱을 한다.

### 언어별 해시테이블 구현 방식

파이썬 딕셔너리는 오픈 어드레싱 형식의 해시 테이블이다. CPython 구현체상으로는, "체이닝 시 `malloc()` 으로 메모리를 할당하는 오버헤드가 높아" 오픈 어드레싱을 택했다고 한다. 또한 《Beautiful Code》 책의 18장, 파이썬의 딕셔너리 구현 에서도 파이썬이 체이닝을 안쓰는 이유를 설명했다. 연결리스트를 만들려면 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 때문에 택하지 않았다.

체이닝에과 선형 탐사 방식의 로드 팩터에 따른 성능비교를 보았을 때, 로드 팩터 `0.8` 전까지는 선형탐사가 압도적으로 캐시실패율이 올라갔지만, 그 전에는 체이닝보다 캐시 실패율이 낮았다.

# Q28) 해시맵 디자인

문제) 다음 기능을 제공하는 해시맵을 디자인하시오.

* put(key, value): 키, 값을 해시맵에 삽입한다. 존재하는 키라면 업데이트한다.
* get(key): 키에 해당하는 값을 조회한다. 키가 존재하지 않으면 -1을 리턴한다.
* remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제한다.

## A1) 개별 체이닝 방식을 이용한 해시 테이블 구현

개별 체이닝 방식의 구현

키 겹치면 해시에 대해 체이닝을 함

해싱은 size 갯수만큼 모듈로연산을 한 나머지



# Q30) 중복 문자 없는 가장 긴 부분 문자열

문제) 중복 문자가 없는 가장 긴 부분 문자열(substring)의 길이를 리턴하시오.

Input1)

```
"abcabcbb"
```

Output1)

```
3
```

설명1)

정답은 "abc"이며 길이는 3이다.

Input2)

```
"bbbbb"
```

Output2)

```
1
```

설명2)

정답은 "b", 길이는 1.

Input3)

```
"pwwkew"
```

Output3)

```
3
```

설명3)

정답은 "wke", 길이는 3.

* 부분문자열 이어야 한다.
* "pwke"는 서브시퀀스다. 연속적이지 않은 문자열이다.

## A1) 슬라이딩 윈도우, 투 포인터로 사이즈 조절

### 어프로치

* 슬라이딩 윈도우로 한칸씩 우측 이동
* 윈도우 내에 중복이 없도록 투 포인터로 윈도우 사이즈를 조절

1. 이미 등장한 문자는 used라는 딕셔너리 문자열 등장 포지션을 넣음
2. **슬라이딩 윈도우 안에있는 문자**를 만났을 때, 해시 테이블에 카운터를 올려줌

양쪽 포인터 모두 왼쪽에서 출발... 두번째 포인터는 오른쪽으로 확장

등장한 문자라면 `used` 안에 있을 것이고, 그러면 포인터를 `used[char] + 1` 로 갱신한다.

처음보는 문자면...

1. `max()` 로 부분문자열의 길이를 확인한다. (최대길이값이.... 현재 유지냐? 아니면 `index - start + 1`이냐? (슬라이딩 윈도우 길이))
2. 더 큰 값인 경우 갱신한다.
3. `used[char] = index` 는 현재 문자를 키로 하는 해시 테이블이다. 현재 위치를 값으로 삽입하는 것을 의미한다.
   1. 다만, 예전에 등장한 적이 있더라도 슬라이딩 윈도우 안에 들어와야한다.

# Q31) 상위 K빈도 요소

문제) 상위 k번 이상 등장하는 요소를 추출하시오.

Input)

```
nums = [1, 1, 1, 2, 2, 3], k = 2
```

Output)

```
[1, 2]
```

## A1) Counter를 이용한 음수 순 추출

### 어프로치

1. 요소의 값을 키로 하는 해시테이블을 만들고 빈도수를 저장.
2. 우선순위 큐를 이용해 상위 `k` 번만큼 추출하면 `k`번 이상 등장하는 요소를 추출할 수 있다. (`heapq`) 사용
   1. 힙에 넣으려면... 다 밀어넣고 `heapify()` , 매번 `heappush()` 수행
   2. 다만 `heappush()` 를 해도 되는 것이, 어차피 저거하면 매번 `heapify()` 를 수행하며, 원래 힙의 삽입방식임
3. 이 때, collections.Counter 로 갯수를 센 딕셔너리의 키/값을 바꿔서 힙에 추가한다.
4. 가장 빈도수가 높은 값을 음수로 바꿔서 min heap을 쓰더라도 빈도수가 높은 값을 출력할 수 있게 한다.
5. `heappop()` 을 통해 `k` 번만큼 값을 추출하면 결과를 얻을 수 있다.

## A2) `most_common()` 메소드 및 `zip()`, `list()` 를 이용한 언패킹

1. 힙에넣고 뺄게 아니라 `most_common()` 메소드만 써도 되고, 이를 해답에 맞게 언패킹하면 더욱 쉽다.
