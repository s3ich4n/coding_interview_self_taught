# 그래프

> 그래프(그래프 이론, 수학): 객체의 일부 쌍(pair)들이 '연관되어' 있는 객체 집합 구조를 의미한다.

그래프 배우면 항상 나오는 "쾨니히스베르크의 다리" 얘기가 나온다. 이걸 갖고 오일러는 당시 기하학으로 풀 수 없음을 캐치했고, 아래와 같은 이야기를 했다.

> 섬을 정점(Vertex)로 두고, 각 다리를 간선(Edge) 로 두었을 때, 모든 정점이 짝수개의 차수(degree)를 가진다면, 모든 다리를 한 번씩만 건너서 도달하는 것이 성립한다.

후대의 수학자가 이를 수학적으로 증명했다. 이를 오일러의 정리라고 부른다.

## 오일러 경로

모든 간선을 한번씩 방문하는 유한 그래프를 오일러 경로라고 부른다.

## 해밀턴 경로

> 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로를 일컫는다.

최적 알고리즘이 없는 대표적인 NP-완전(Complete) 문제다. (cf. NP 문제중 NP-난해(Hard)문제를 NP-완전 문제라고 부른다. P-NP 문제는 후술한다)

원래 출발점으로 되돌아오는 경로는 해밀턴 순환(Hamiltonian Cycle)이라고 한다. 이 중 최단거리를 찾는 문제는 외판원 문제(Travelling Selesman Problem, TSP)라고 한다. 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제다. 다시말해, 최단 거리인 해밀턴 순환을 찾는 문제이며, NP-Hard 문제다. 

## P-NP

NP는 비결정론적 튜링 기계(NTM)이다. 다항시간 안에 풀 수 있는 판정문제의 집합이다. NP는 Non-deterministic Polynomial time, 비결정론적 다항시간의 약자다.

NP 문제는 결정론적 튜링 기계로 다항 시간에 검증이 가능하고, 그 역도 성립한다. 결정론적 튜링기계로 다항 시간 안에 풀 수 있는 문제는 비결정론적 튜링 기계로도 다항시간 안에 풀 수 있다. 따라서 P 집합은 NP 집합의 부분집합이다. 이 때 P가 NP의 진부분집합(Proper Subset)인지, 혹은 P와 NP가 같은지는 알 수 없다.

* 해밀턴 경로: 한 번만 방문
* 해밀턴 순환: 한 번만 방문해서 출발지로
* 외판원 문제: 한 번만 방문해서 출발지로 오는 경로 중 가장 짧은 경로

-> 이런 생각을 해볼 수 있다!

* 해밀턴 경로가 있나?
* 각 도시를 방문하고 돌아오는 가장 짧은 경로는? (최단거리 해밀턴 순환은? -> 외판원 문제의 해결책)

NP-완전(Complete) 문제의 조건

* NP 문제다
* NP-난해(hard) 문제다

## 그래프 순회

> 그래프 탐색이라고도 부르며, 그래프의 각 정점을 방문하는 과정을 의미한다.

* 그래프 순회는 깊이 우선 탐색(DFS, Depth-First Search), 넓이 우선 탐색(BFS, Breadth-First Search)가 있다.
* DFS는 주로 스택, 재귀로 푼다. 백트래킹과 함께 뛰어난 효용을 보인다.
* BFS는 큐로 구현하며, 그래프의 최단경로를 구하는 문제에 쓰인다.

그래프를 표현하는 방법은 인접행렬(Adjacency Matrix), 인접 리스트(Adjacency List)가 있다. 딕셔너리 형식의 리스트로 하여 구현을 연습한다.

### DFS(깊이 우선 탐색)

일반적으로는 스택으로 구현한다. 아니면 재귀를 쓴다. 재귀쪽이 좀더 선호된다.

#### 재귀를 통한 구현

pseudo-code

```
DFS(G, v)
	label v as discovered
	for all directed edges from v to w that are in G.adjacentEdges(v) do
		if vertex w is not labeled as discovered then
			recursively call DFS(G, w)
```

정점 v의 모든 인접 유향(Directed) 간선을 반복하라고 나온다.

쫓아가보면 금방 함.

타고 들어갔다가, 스택 타고 나오면서 그 시점에 갖고있는 배열을 알아서 잘 보관하고있단 점만 이해하고있으면 재귀로 풀림.

#### 스택을 통한 반복구조로 구현

pseudo-code

```
DFS-iterative(G, v)
	let S be a stack
	S.push(v)
	while S is not empty do
		v = S.pop()
		if v is not labeled as discovered then
			label v as discovered
			for all edges from v to w in G.adgacentEdges(v) do
				S.push(w)
```

스택을 이용해 모든 인접간선을 추출하고, 다시 도착점인 정점을 스택에 추가.

쫓아가는건 문제 없으나, 루트부터 **역순으로 방문**함에 유의한다.

### BFS(너비 우선 탐색)

최단경로를 찾는 다익스트라 알고리즘 등에 매우 유용히 쓰인다.

#### 큐를 이용한 반복구조로 표현

pseudo-code

```
BFS(G, start_v)
	let Q be a queue
	label start_v as discovered
	Q.enqueue(start_v)
	while Q is not empty do
		v := Q.dequeue()
		if v is the goal then
			return v
		for all edges from to w in G.adjacentEdges(v) to
			if w is now labeled as discovered then
				label w as discovered
				w.parent := v
				Q.enqueue(w)
```

모든 인접간선을 추출하고 도착점인 정점을 큐에 삽입한다.

#### 재귀 구현?

**안됨**

## 백트래킹

> 해결책에 대해 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(백트랙, Backtrack)하여 정답을 찾는 범용적인 알고리즘. 제약 충족 문제(Constraint Satisfaction Problems)에 유용하다.

DFS와 엮여서 항상 이야기된다.

백트래킹은 검색 시 더 나아갈 수 없으면 왔던길을 되돌아가서 다른 길을 찾는다는 것을 의미한다. 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻하며, DFS는 백트래킹의 골격을 이루는 알고리즘이다. 백트래킹은 주로 재귀로 구현하며, 알고리즘마다 DFS 변형이 있긴하지만 기본적으로 모두 DFS의 범주에 속한다. 최악의 경우 왔다갔다를 모두 반복하지만, 가능성이 없으면 포기한단 점에서 훨씬 우아하다. 이를 트리의 가지치기(Pruning)이라고 한다. 불필요한 부분을 빨리 포기하면 탐색 최적화 또한 수행할 수 있기 때문에, 트리 탐색 최적화와도 관련이 깊다. 

## 제약 충족 문제

> 수많은 제약조건(Constraint)을 충족하는 상태(States)를 찾아내는 수학문제를 말한다.

백트래킹은 제약 충족문제를 풀이하는데 필수적이다. 가지치기를 통해 제약 충족 문제를 최적화하기 때문이다. 합리적인 시간 내에 문제를 풀기 위해 휴리스틱과 조합 탐색과 같은 개념을 함께 결합하여 문제를 풀이한다.

# Q32) 섬의 개수

문제)

`1`을 육지로, `0`을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 갯수를 계산하시오. (연결되어있는 1의 덩어리 갯수를 의미)

Input 1)

```
11110
11010
11000
00000
```

Output 1)

```
1
```

Input 2)

`````
11000
11000
00100
00011
`````

Output)

```
3
```

## A1) DFS로 그래프 탐색

### 어프로치

동서남북이 모두 연결된 그래프로 가정하에, 네 방향에 대해 DFS 재귀를 통해 탐색을 마치고 난 후 1을 증가시킨다.

1. 행열 단위로 육지(1)인 곳을 찾아 진행하다가, 육지를 발견하면 `dfs()` 함수를 호출한다.
2. 재귀호출이 백트래킹으로 모두 나오면 섬 하나를 발견한 것으로 간주한다. 방문한 곳은 `1`로(`#` 등, 육지가 아닌 것으로 간주할 수 있으면 됨)마킹한다.
3. 육지가 아닌 곳은 `return` 으로 종료한다.

cf) 방문경로를 저장할 필요는 없다. 공간복잡도가 따로 생기기때문. 차라리 입력값을 "수정"해서 쓰는게 좀더 이득.

쫓아가보면 캐치할 수 있는 문제라고 생각함.

# Q33) 전화번호 문자 조합

문제) 

2~9까지 숫자가 주어졌을 때, 전화번호로 조합 가능한 모든 문자를 출력하시오.

Input)

```
"23"
```

Output)

```
["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
```

## A1) 모든 조합 탐색

전체를 탐색해야함. 항상 전체탐색이 필요하고, 가지치기가 안됨. 

a b c가 루트고 d e f 가 a b c에 각각 붙는다고 생각하면 됨

### 어프로치

끝까지 탐색하고나면 백트래킹해야함!

입력값을 자릿수로 쪼개어 반복하고, 숫자에 해당하는 모든 문자열을 반복하면서 마찬가지로 문자 단위로 재귀탐색을 수행.

# Q34) 순열

문제) 

서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하시오.

Input)

```
[1, 2, 3]
```

Output)

```
[
	[1,2,3],
	[1,3,2],
	[2,1,3],
	[2,3,1],
	[3,1,2],
	[3,2,1],
]
```

## A1) DFS를 활용한 순열 생성

모든 경우는 빈 루트에서 리프 노드에 하나씩 값을 추가하는 트리라고 할 수 있다.

### 어프로치

1. `prev_elements` 를 통해 직전에 참조한 리프노드의 값을 저장
2. `next_elements` 는 파라미터로 들어온 `elements` 의 "그 시점의 값"을 "참조"한다.



리프면 결과를 추가하고 끝에 도달했을 때 (`len(elements) == 0` 일 때) 결과를 하나씩 담는다.

결과를 추가할 때 `prev_elements[:]` 라고 되어있는데, 이건 객체 참조가 아니라 `prev_elements` 의 값 자체를 복사하는 것이다. 그냥 `copy()`를 하는 것과 다를게 없다(단독 리스트면). 리스트가 서로 중첩되어있는 등, 복잡한 리스트는 `deepcopy()` 로 처리한다. 

#### 이거 좀더 자세히 파면?

* https://stackoverflow.com/q/17246693

  * `copy.copy()`, `copy.deepcopy()` 나 새 주소에 값을 쓰는건 맞는데
  * *nested list* 처리는 `deepcopy` 를 써야함.

  ```python
  import copy
  
  i = [1, 2, 3, [4, 5]]
  # 아래 두 값 들을 각각 하나씩 주석해제하여 구동해보면 알 수 있다.
  # 이 사이트 사용: https://pythontutor.com/visualize.html
  # j = copy.deepcopy(i)
  # j = copy.copy(i)
  
  print(hex(id(i)), hex(id(j)))
  
  i[3].append(6)
  print(j)
  
  ```

  

* 여기 있는 대답들을 하나하나 다 봐라!

`prev_elements` 에 접근이 가능한건 파이썬 특임. 쟤는 참고로 *free variable* 이라 부름. [공식문서](https://docs.python.org/3/reference/executionmodel.html) [참고링크2](https://zetawiki.com/wiki/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%9E%90%EC%9C%A0%EB%B3%80%EC%88%98)

이거 혼용하면 잘못쓰기 정말 쉬우니, `nonlocal` 키워드나 `global` 키워드를 읽어볼 것. 실무에서 쓰는지는 몰?루

## A2) `itertools` 사용

효율적이고, 최적화되어있고, 버그 발생가능성이 현저히 적다. 안 쓸 이유가 없음.

`list(itertools.permutations[nums])` 끝.

# Q35) 조합

문제)

전체 수 n을 받아 k개의 조합(combination)을 리턴하시오.

Input)

```
n = 4, k = 2
```

Output)

```
[
	[2, 4],
	[3, 4],
	[2, 3],
	[1, 2],
	[1, 3],
	[1, 4],
]
```

## A1) DFS로 `k` 개의 조합 생성

### 어프로치

자기자신, 앞의 모든 요소를 배제하고 `next_elements` 를 구성한다.

재귀 호출 시 넘겨주는 값은 자기 자신 이전의 모든 값을 고정하여 넘긴다 → 남아있는 값끼리 조합을 수행.

`k` 개의 조합만을 생성해야하니, `k` 값을 별도로 받고 그 값을 줄여가며 재귀호출하는 방식. `k == 0` 이면 나가는 로직이 그로인해 있다.

## A2) `itertools` 사용

효율적, 최적회됨, 버그발생이 적음.

`list(itertools.permutations(range(1, n + 1), k))`

# Q36) 조합의 합

문제)

숫자 집합 `candidates` 를 조합하여, 합이 `target` 이 되는 원소를 나열하시오. 각 원소는 중복으로 나열 가능하다.

Input 1)

```
candidates = [2, 3, 6, 7], target = 7
```

Output 1)

```
[
	[7],
	[2, 2, 3],
]
```

Input 2)

```
candidates = [2, 3, 5], target = 8
```

Output 2)

```
[
	[2, 2, 2, 2],
	[2, 3, 3],
	[3, 5],
]
```

## A1) DFS로 중복 조합 그래프 탐색

### 어프로치

* DFS와 백트래킹을 통해... 중복 조합 중 가지치기를 하는 것이 좋다.
* 모든 중복**조합**에서 값을 찾아야하기 때문에, 부모의 값부터 시작하는 그래프로 찾아간다.
* 조합은 각각의 노드가 자기 자신부터 하위원소까지의 나열로만 정리할 수 있다.

코드는 아래와 같은 방식으로 찾아가보자:

1. `csum` 이란 변수로, 현재 목표하는 값의 참조의 참조를 통해 판단할 수 있게 한다.
2. `for` loop 구간은 다음 값들을 순회하기 위한 조건이다.
3. 저장된 값은 `path` 에 넣고 계속해서 저장해보고 루프를 돌린다(루프에다가만 값을 넣고 더하는것도 결국 연산이라 이런 방법을 택한 것 같다).

# Q37) 부분 집합

문제)

모든 부분집합을 리턴하시오.

Input)

```
nums = [1, 2, 3]
```

Output)

```
[
	[3],
	[1],
	[2],
	[1,2,3],
	[1,3],
	[2,3],
	[1,2],
	[],
]
```

## A1) 트리의 모든 DFS 결과

트리를 DFS 후, 인덱스를 1씩 늘려서 깊이 탐색을 하고, 결과는 탐색을 마칠 때마다 저장하면 될 것이다.

### 어프로치

`path` 값에 경로를 만들어나가면서 인덱스를 1씩 증가하여 깊이탐색을 수행한다. 종료조건 없이 탐색이 끝나면 함수가 종료되도록 한다.

결과는 탐색을 하면서 계속하여 결과를 추가해준다.

## 이것과는 별개로... [기출]

`[1, 2, 3]`  넣었을 때,

```
[
	[1],
	[2],
	[3],
	[1,2],
	[2,3],
	[1,2,3],
]
```

만 나오도록 하는 걸 설계해보자.

일단 저 새끼가 뭔지부터 알면 해결이 쉬울듯하다.

### 어프로치

내 생각에는 트리의 왼쪽만 항상 순회하면 답이 나오는건데, 이대로...

`[1, 2, 3]` 이 있으면,

* 1은 2일 때 [1, 2], 3일때 [1, 2, 3]
* 2는 3일때 [2, 3]
* 3은 자기자신인 3 (근데 이새끼는 지가 맨 끝인것도 알고 있어야 해서 이걸 어떻게 해결해야할까?)

# Q38) 일정 재구성

문제)

`[from, to]` 로 구성된 항공권 목록을 이용하여 `JFK` 에서 출발하는 여행 일정을 구성하시오.

단, 여러 일정이 있는 경우 **사전 어휘 순(Lexical Order)**으로 방문한다.

Input 1)

```python
[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
```

Output 1)

```
["JFK", "MUC", "LHR", "SFO", "SJC"]
```

Input 2)

```python
[["JFK", "SFO"], ["JFK", "ATL"], ["SFO", "ATL"], ["ATL", "JFK"], ["ATL", "SFO"]]
```

Output 2)

```
["JFK", "ATL", "JFK", "SFO", "ATL", "SFO"]
```

설명 2)

* `["JFK", "SFO", "JFK", "ATL", "ATL", "SFO"]` 도 가능하지만, 사전 어휘 순이 아니므로 정답이 아니다.

## A1) DFS로 일정 그래프 구성

* 방향이 있는 그래프(Directed Graph)로 구성하면, DFS로 풀이가 가능하다.
* **중복된 일정의 경우, 어휘순임을 유의.**

### 어프로치

1. `defaultdict` 를 활용하여 그래프를 구성한다. 이때 어휘 순 정렬을 한 채로 그래프로 구성하도록 하자.
2. 재귀형식으로 그래프에서 하나씩 꺼내서 결과에 추가한다.
   1. 결과 리스트에는 역순으로 담길 것이다
   2. `pop()`  으로 하나씩 꺼낼 것이기 때문에 재방문하지 않는다.

## A2) 스택 연산으로 큐 연산 최적화 시도

* 첫번째 값을 꺼내는 `pop(0)` 연산의 시간복잡도가 O(n) 이니, 처음 그래프 생성 부터 `reverse` 하여 넣으면 될것이다.
* 결과 리스트에 역순으로 담기는 것도 똑같음
* 따라서 정답 리턴 할 때도 역으로 뒤집는 건 똑같음.

## A3) 일정 그래프 반복을 통한 풀이

반복문으로 푼다면? 우선 아래와 같이 넣는 건 동일하다. (그래프 생성)

```
graph = collections.defaultdict(list)
for a, b in sorted(tickets)
	graph[a].append(b)
```

끄집어낼 때 반복문으로.

1. `JFK` 부터 타고 들어가서
2. 안에있는 `ATL`을 타고 그 키값인 `ATL`의 `0`번 을 꺼냄.
3. 다시 `JFK` 으로 타고가서 `0` 번을 꺼냄.

### 문제점!

이 그래프의 경로는 이어지지만, 경로가 이어지지 않는 경우가 있다. 이럴 땐 스택을 pop하면서 경로저장 따로, 스택따로 관리한다.

# Q39) 코스 스케줄

문제)

`0` 을 완료하기 위해서는 `1`을 끝내야 한다는 것을 `[0, 1]` 쌍으로 표현하는 `n` 개의 코스가 있다. 코스 개수 `n`과 이 쌍들을 입력으로 받았을 때 모든 코스가 완료 가능한지 판단하라.

입력 1)

```
2, [[1, 0]]
```

출력 1)

```
True
```

설명 1)

2개의 코스가 있으며, 1을 완료하기 위해 0을 끝내면 된다 → 가능

입력 2)

```
2, [[1, 0], [0, 1]]
```

출력 2)

``` 
False
```

설명 2)

2개의 코스가 있으며, 1을 끝내기 위해서는 0을 끝내야하고, 0을 끝내기 위해서는 1을 끝내야 한다 → 불가능

## A1) DFS로 순환 구조 판별

### 어프로치

**그래프가 순환(Cyclic)인지 판별**한다. 순환구조라면 맴돌것이고, 해당 코스는 처리할 수 없기 때문이다. 순환 판별 알고리즘을 차례로 구현한다.

### 풀이 분석

일단 그래프 생성. 첫째 값은 x, 둘째 값은 y로 하고, y는 복수개로 구성할 수 있도록 한다. `'x': ['y1', 'y2']` 형식의 구조가 될 것임.

```
graph = collections.defaultdict(list)
for x, y in prerequisties:
	graph[x].append(y)
```

순환 구조를 판별하기 위해, 방문한 노드를 `traced` 변수에 저장한다. 중복 방문하게 되면 순환구조로 간주할 수 있고, 이 경우 `False` 를 리턴하고 종료한다.

```
traced = set()
(생략)
for x in graph:
	if not dfs(x):
		return False

return True
```

순환 구조를 찾는것은 DFS로 진행한다. DFS 함수인 `dfs()` 에서는 현재 노드가 이미 방문했던 노드 집합인 `traced`에 존재한다면 순환구조 이므로 `False`를 리턴한다. `False`는 계속 상위로 리턴되어 최종 결과도 `False` 를 리턴하게 됨.

탐색은 재귀로 하되, 해당 노드를 이용한 모든 탐색이 끝나면 `traced.remove(i)` 로 방문이력을 반드시 지워야한다. 아니면 형제(Sibling) 노드가 방문한 노드까지 남게되어, 자식 노드 입장에서는 순환이 아닌데 순환이라고 오판할 수 있기 때문이다.

```
def dfs(i):
	if i in traced:
		return False
	traced.add(i)
	for y in graph[i]:
		if not dfs(y):
			return False
	traced.remove(i)
	
	return True
```

## A2) 가지치기 추가

A1은 순환이 생길 때 까지 모든 자식을 도는거였는데, 순환이 아니라 복잡하게 서로 도는 케이스에서는 불필요하게 동일 그래프를 여러 번 돌 수도 있다. 돌았던 곳은 True로 개선하면 탐색시간이 훨씬 줄어들 것이다. (정석적인 접근)

