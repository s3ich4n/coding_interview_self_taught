# 트리

> 트리는 계층형 트리 구조를 시뮬레이션하는 ADT이다. 루트값과 부모-자식 간 서브트리로 구성되며, 서로 연결된 노드의 집합이다.

트리는 진짜 나무처럼 아래로 뻗어가는 자료구조다.

재귀로 정의된(Recursively Defined) 자기 참조 자료구조이다. 트리는 자식도 트리고, 그 자식도 트리다. 이를 일컬어 서브트리로 구성된다 라고 한다. 이 탓에 트리에서는 재귀 순회가 훨씬 자연스럽다.

## 트리의 명칭

트리는 루트(Root)부터 시작된다. 루트는 자식(Child) 노드를 가지며, 간선(Edge)으로 연결되어있다. 자식노드의 개수는 차수(Degree)라고 하며, 크기(Size)는 자신을 포함한 모든 자식 노드의 개수다. 높이(Height)는 현재 위치에서 리프(Leaf)까지의 거리, 깊이(Depth)는 루트에서 현재 노드까지의 거리를 의미한다(리프는 가장 아래 자식노드를 의미). 레벨은 0부터 시작한다. 트리는 단방향(Uni-Directional)이다. 일반적으로 위에서 아래로 향한다.

## 그래프 vs. 트리

> 트리는 순환 구조를 갖지 않는 그래프다.

순환이 없다. 이게 핵심. 부모가 둘 이상일 수 없고 루트도 하나여야 하며, 순환구조도 없어야함.

## 이진 트리

노드의 모든 차수가 2 이하면 이진트리(Binary Tree)이다.

### 이진트리의 종류

* full binary tree: 모든 노드가 0개 아니면 2개의 자식노드를 가짐
* complete binary tree: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져있다. 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져있다.
* perfect binary tree: 모든 노드가 2개의 자식노드를 가지고있으며, 모든 리프노드가 동일한 깊이/레벨을 갖는다. 가장 꽉차있음.

# Q42) 이진 트리의 최대 깊이

문제)

이진 트리의 최대 깊이를 구하시오.

Input)

```
[3, 9, 20, null, null, 15, 7]
```

Output)

```
3
```

## A1) 반복 구조로 BFS 풀이

너비 우선탐색, 반복구조로 풀이.

기억하세요: DFS는 스택으로, BFS는 큐로. (책의 323페이지 참조) 그리고 BFS는 재귀가 안된다는 사실 기억합시다잉

### 어프로치

1. deque로 쓰면 큐/스택처럼 다 쓸 수 있으니까 사용.
2. 왼쪽의 왼쪽/오른쪽 자식을 보고 큐에 넣으면, 다음 depth를 바라보는 것과 같다
3. 그 방법대로 계속해서 아래로 타고 내려간다.

# Q43) 이진 트리의 직경(Diameter)

문제)

이진 트리에서 두 노드 간 가장 긴 경로의 길이를 출력하시오.

이진 트리가 주어졌을 때, `[1, 2, 3, 4, 5, null, null]` 가장 긴 경로는 4->2->1->3 또는 5->2->1->3으로 3이다.

## A1) 상태값 누적 트리 DFS

리프노드까지 가장 아래로 타고간 후에, 부모로 거슬러가서 상태값 업데이트를 진행하며 맨 끝을 찾으면?

참고할 학습링크는 [여기](https://www.youtube.com/watch?v=bkxqA8Rfv04)를 보도록 합니다.

### 어프로치

1. 존재하지 않는 노드에는 `-1` 이라는 값을 부여.
2. 거슬러 올라가서 왼쪽 전체길이 + 오른쪽 전체길이 + `2` 를 계산한다.
   1. `2`?: 현재 노드와 왼쪽, 오른쪽 자식 노드와의 거리

### 어프로치 2

* 상태값: 리프노드에서 현재노드까지의 거리
* 거리: 왼쪽 자식노드의 상태값 + 오른쪽 자식노드의 상태값 + 2

### 최종 어프로치

리프노드까지 DFS로 타고들어왔다면...

* 최종결과가 될 가장 긴 경로 `self.longest`, 상태값 `max(left, right) + 1`
* bottom-up 식으로 접근한다.
  * 맨 아래부터 서브트리의 루트 높이가 `0`이고, 노드 탐색할 때 `+1` 을 하는 이유, null 값(없는 리프)에 대해 `-1` 처리하는 부분을 이해하면 된다.

# Q44) 가장 긴 동일 값의 경로

문제)

동일한 값을 지닌 가장 긴 경로를 찾으시오.

Input 1)

[0] 인덱스가 루트고, BFS로 타고 들어가면 됩니다잉

```
[5, 4, 5, 1, 1, None, 5]
```

Output 1)

```
2
```

설명 1)

루트에서 오른쪽 노드 끝까지 5->5->5로, 가장 긴 **이동거리**가 `2` 이다.

Input 2)

```
[1, 4, 5, 4, 4, None, 5]
```

Output)

```
2
```

설명 2)

왼쪽 리프 노드 4에서 형제노드 4까지 4->4->4로 가장 긴 이동 거리가 2이다.

## A1) 상태값 거리 계산 DFS

Q43과 유사하다. DFS로 내려가고, 값이 일치하면 거리를 차곡차곡 쌓아 올라가면서 백트래킹을 실시한다(여기까진 같음).

### 어프로치

* 리프노드까지 타고가서 거리 계산을 한다.
* 현재노드와 자식노드가 같다면 거리 +1을 수행한다.
* 좌측/우측 중, 가장 거리가 긴 최댓값을 결과로 쓴다.
* 자식노드 상태값 중 큰값을 리턴한다(**백트래킹**!)

# Q45) 이진트리 반전

중앙을 기준으로 이진트리를 반전시키시오.

Input)

```
[4, 2, 7, 1, 3, 6, 9]
```

Output)

```
[4, 7, 2, 9, 6, 1, 3]
```

## A1) 파이써닉 웨이

타고타고 들어가서 왼쪽-오른쪽을 바꾸면? 끝까지 쭉 타고들어가서 왼쪽 오른쪽을 확인하고, 리턴됐을 때 **한번에** 값 추가한다.

어떻게 풀면 재귀가 괜찮은건지? 그러한 캐치를 확실하게 하자구요

얘는 bottom-up 방식!

## A2) 반복 구조로 BFS

큐에다가 넣고 부모 노드부터 좌우로 스왑해서 "내려간다".

1. 큐에 루트 넣고, 좌우스왑 후 `left`, `right` 넣고
2. `dequeue()`해서 또 좌우로 스왑, `None` 도 넣음! → `if node` 구문으로 갈리기때문. 나중엔 큐에 `None` 만 남는다!
3. 스왑 다 끝나면 루트만 리턴

위에서부터 치고 내려가니까 얘는 top-down 방식!

## A3) 반복 구조로 DFS

DFS로 풀려면?

스택에 넣고 부모 노드부터 좌우로 스왑해서 "내려간다".

1. 스택에 루트넣고, 좌우스왑 후 `left`, `right` 넣고
2. `pop()` 해서 또 좌우로 스왑, 깊숙하게 들어가서 `None` 까지 들어갔다가 pop하면서 다시 재귀를 돌아옴
3. 스왑 다 끝나면 루트만 리턴

## A4) 반복 구조로 DFS "후위 순회"

전위순회 후위순회는 스택에 넣고 빼고 순서만 뒤집어주면 된다.

A3 풀이에서 스택에 넣고 스왑하는 순서만 뒤집어주면 된다. 대학교때 했던 그거임. 후에 가서 복습하자

# Q46) 두 이진 트리 병합

문제)

두 이진트리를 병합하시오. 중복되는 노드는 값을 합산한다.

Input)

```
tree1 = [1, 3, 2, 5, None, None, None]
tree2 = [2, 1, 3, None, 4, None, 7]
```

Output)

```
[3, 4, 5, 5, 4, None, 7]
```

## A1) 재귀 탐색

### 어프로치

1. 트리 루트 두개를 넣는다

2. 신규 `TreeNode` 객체를 생성한다.

   1. 좌측에는 left값들을 더한 재귀결과를 담는다.
   2. 우측에는 right값들을 더한 재귀결과를 담는다.
   3. 이 후 `node` 를 리턴.

3. 트리 한쪽이 없으면?

   1. `return t1 or t2` 로 있는놈 하나를 리턴.

      ```python
      >>> def tes1():
      ...     return 1 or None
      ...
      >>> tes1()
      1
      >>> def tes1():
      ...     return None or 2
      ...
      >>> tes1()
      2
      >>>
      ```

   2. 허 이게되네....;

