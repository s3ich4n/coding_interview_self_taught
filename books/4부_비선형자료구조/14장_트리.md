# 트리

> 트리는 계층형 트리 구조를 시뮬레이션하는 ADT이다. 루트값과 부모-자식 간 서브트리로 구성되며, 서로 연결된 노드의 집합이다.

트리는 진짜 나무처럼 아래로 뻗어가는 자료구조다.

재귀로 정의된(Recursively Defined) 자기 참조 자료구조이다. 트리는 자식도 트리고, 그 자식도 트리다. 이를 일컬어 서브트리로 구성된다 라고 한다. 이 탓에 트리에서는 재귀 순회가 훨씬 자연스럽다.

## 트리의 명칭

트리는 루트(Root)부터 시작된다. 루트는 자식(Child) 노드를 가지며, 간선(Edge)으로 연결되어있다. 자식노드의 개수는 차수(Degree)라고 하며, 크기(Size)는 자신을 포함한 모든 자식 노드의 개수다. 높이(Height)는 현재 위치에서 리프(Leaf)까지의 거리, 깊이(Depth)는 루트에서 현재 노드까지의 거리를 의미한다(리프는 가장 아래 자식노드를 의미). 레벨은 0부터 시작한다. 트리는 단방향(Uni-Directional)이다. 일반적으로 위에서 아래로 향한다.

## 그래프 vs. 트리

> 트리는 순환 구조를 갖지 않는 그래프다.

순환이 없다. 이게 핵심. 부모가 둘 이상일 수 없고 루트도 하나여야 하며, 순환구조도 없어야함.

## 이진 트리

노드의 모든 차수가 2 이하면 이진트리(Binary Tree)이다.

### 이진트리의 종류

- full binary tree: 모든 노드가 0개 아니면 2개의 자식노드를 가짐
- complete binary tree: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져있다. 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져있다.
- perfect binary tree: 모든 노드가 2개의 자식노드를 가지고있으며, 모든 리프노드가 동일한 깊이/레벨을 갖는다. 가장 꽉차있음.

# Q42) 이진 트리의 최대 깊이

문제)

이진 트리의 최대 깊이를 구하시오.

Input)

```
[3, 9, 20, None, None, 15, 7]
```

Output)

```
3
```

## A1) 반복 구조로 BFS 풀이

너비 우선탐색, 반복구조로 풀이.

기억하세요: DFS는 스택으로, BFS는 큐로. (책의 323페이지 참조) 그리고 BFS는 재귀가 안된다는 사실 기억합시다잉

### 어프로치

1. deque로 쓰면 큐/스택처럼 다 쓸 수 있으니까 사용.
2. 왼쪽의 왼쪽/오른쪽 자식을 보고 큐에 넣으면, 다음 depth를 바라보는 것과 같다
3. 그 방법대로 계속해서 아래로 타고 내려간다.

# Q43) 이진 트리의 직경(Diameter)

문제)

이진 트리에서 두 노드 간 가장 긴 경로의 길이를 출력하시오.

이진 트리가 주어졌을 때, `[1, 2, 3, 4, 5, None, None]` 가장 긴 경로는 4->2->1->3 또는 5->2->1->3으로 3이다.

## A1) 상태값 누적 트리 DFS

리프노드까지 가장 아래로 타고간 후에, 부모로 거슬러가서 상태값 업데이트를 진행하며 맨 끝을 찾으면?

참고할 학습링크는 [여기](https://www.youtube.com/watch?v=bkxqA8Rfv04)를 보도록 합니다.

### 어프로치

1. 존재하지 않는 노드에는 `-1` 이라는 값을 부여.
2. 거슬러 올라가서 왼쪽 전체길이 + 오른쪽 전체길이 + `2` 를 계산한다.
   1. `2`?: 현재 노드와 왼쪽, 오른쪽 자식 노드와의 거리

### 어프로치 2

- 상태값: 리프노드에서 현재노드까지의 거리
- 거리: 왼쪽 자식노드의 상태값 + 오른쪽 자식노드의 상태값 + 2

### 최종 어프로치

리프노드까지 DFS로 타고들어왔다면...

- 최종결과가 될 가장 긴 경로 `self.longest`, 상태값 `max(left, right) + 1`
- bottom-up 식으로 접근한다.
  - 맨 아래부터 서브트리의 루트 높이가 `0`이고, 노드 탐색할 때 `+1` 을 하는 이유, None 값(없는 리프)에 대해 `-1` 처리하는 부분을 이해하면 된다.

# Q44) 가장 긴 동일 값의 경로

문제)

동일한 값을 지닌 가장 긴 경로를 찾으시오.

Input 1)

[0] 인덱스가 루트고, BFS로 타고 들어가면 됩니다잉

```
[5, 4, 5, 1, 1, None, 5]
```

Output 1)

```
2
```

설명 1)

루트에서 오른쪽 노드 끝까지 5->5->5로, 가장 긴 **이동거리**가 `2` 이다.

Input 2)

```
[1, 4, 5, 4, 4, None, 5]
```

Output)

```
2
```

설명 2)

왼쪽 리프 노드 4에서 형제노드 4까지 4->4->4로 가장 긴 이동 거리가 2이다.

## A1) 상태값 거리 계산 DFS

Q43과 유사하다. DFS로 내려가고, 값이 일치하면 거리를 차곡차곡 쌓아 올라가면서 백트래킹을 실시한다(여기까진 같음).

### 어프로치

- 리프노드까지 타고가서 거리 계산을 한다.
- 현재노드와 자식노드가 같다면 거리 +1을 수행한다.
- 좌측/우측 중, 가장 거리가 긴 최댓값을 결과로 쓴다.
- 자식노드 상태값 중 큰값을 리턴한다(**백트래킹**!)

# Q45) 이진트리 반전

중앙을 기준으로 이진트리를 반전시키시오.

Input)

```
[4, 2, 7, 1, 3, 6, 9]
```

Output)

```
[4, 7, 2, 9, 6, 1, 3]
```

## A1) 파이써닉 웨이

타고타고 들어가서 왼쪽-오른쪽을 바꾸면? 끝까지 쭉 타고들어가서 왼쪽 오른쪽을 확인하고, 리턴됐을 때 **한번에** 값 추가한다.

어떻게 풀면 재귀가 괜찮은건지? 그러한 캐치를 확실하게 하자구요

얘는 bottom-up 방식!

## A2) 반복 구조로 BFS

큐에다가 넣고 부모 노드부터 좌우로 스왑해서 "내려간다".

1. 큐에 루트 넣고, 좌우스왑 후 `left`, `right` 넣고
2. `dequeue()`해서 또 좌우로 스왑, `None` 도 넣음! → `if node` 구문으로 갈리기때문. 나중엔 큐에 `None` 만 남는다!
3. 스왑 다 끝나면 루트만 리턴

위에서부터 치고 내려가니까 얘는 top-down 방식!

## A3) 반복 구조로 DFS

DFS로 풀려면?

스택에 넣고 부모 노드부터 좌우로 스왑해서 "내려간다".

1. 스택에 루트넣고, 좌우스왑 후 `left`, `right` 넣고
2. `pop()` 해서 또 좌우로 스왑, 깊숙하게 들어가서 `None` 까지 들어갔다가 pop하면서 다시 재귀를 돌아옴
3. 스왑 다 끝나면 루트만 리턴

## A4) 반복 구조로 DFS "후위 순회"

전위순회 후위순회는 스택에 넣고 빼고 순서만 뒤집어주면 된다.

A3 풀이에서 스택에 넣고 스왑하는 순서만 뒤집어주면 된다. 대학교때 했던 그거임. 후에 가서 복습하자

# Q46) 두 이진 트리 병합

문제)

두 이진트리를 병합하시오. 중복되는 노드는 값을 합산한다.

Input)

```
tree1 = [1, 3, 2, 5, None, None, None]
tree2 = [2, 1, 3, None, 4, None, 7]
```

Output)

```
[3, 4, 5, 5, 4, None, 7]
```

## A1) 재귀 탐색

### 어프로치

1. 트리 루트 두개를 넣는다

2. 신규 `TreeNode` 객체를 생성한다.

   1. 좌측에는 left값들을 더한 재귀결과를 담는다.
   2. 우측에는 right값들을 더한 재귀결과를 담는다.
   3. 이 후 `node` 를 리턴.

3. 트리 한쪽이 없으면?

   1. `return t1 or t2` 로 있는놈 하나를 리턴.

      ```python
      >>> def tes1():
      ...     return 1 or None
      ...
      >>> tes1()
      1
      >>> def tes1():
      ...     return None or 2
      ...
      >>> tes1()
      2
      >>>
      ```

   2. 허 이게되네....;

# Q47) 이진트리 직렬화 & 역직렬화

문제)

이진트리를 배열로 직렬화하고, 반대로 역직렬화하는 기능을 구현하시오.

```
배열: [1, 2, 3, None, None, 4, 5] 형식으로 직렬화
메모리 상에 이진 트리가 구성되도록 역직렬화도 가능하도록 기능구현 필요
```

## A1) 직렬화 & 역직렬화 구현

이를 구현하기 위해선 이진트리의 특징/표현을 알아야 한다. 이진트리는 논리적인 구조이며, 이를 파일/디스크로 저장하려면 물리적인 구조로 바꿔줘야한다. 이것이 직렬화(Serialize)이다. 반대로, 물리적 구조를 논리적 구조로 되돌리는 것은 역직렬화(Deserialize) 라고 한다.

이진 힙, 즉 Complete Binary Tree(완전 이진트리 라고 한다)는 높이 순서대로 순회하면, 배열에 낭비없이 배치할 수 있다. 그러나 그렇지 않은 경우에는 None으로 표기하거나, 나름의 약속대로 규칙을 정해야 한다.

배열 방식으로 표현할 때는, 편리한 계산을 위해 인덱스를 `1`부터 사용함에 유의한다. 몇가지 규칙이 있는데, 그 수식은 아래와 같다

- 부모/자식 노드의 위치는 각각 부모 `[i/2]`, 왼쪽 자식 `2i`, 오른쪽 자식 `2i + 1`
- 비어있는 위치는 `None` 으로 표기 (혹은 다른 문자열이나...)

### 어프로치 - 직렬화

문제에 내가 써놨듯, BFS로 하는 편이 좀더 이해가 빠르다고 생각한다. (책엔 트리 그림으로 그려져있다. 궁금하시면 책을 사셔서 보시면 바로 캐치하실 수 있습니다!)

위에 요약한 것 처럼 트리에 대해 BFS 탐색을 하면서 결과를 인덱스에 담고 리턴해주면 될듯하다.

# Q48) 균형 이진 트리

문제)

이진 트리가 높이 균형(Height-balanced) 인지 판단하시오. 높이 균형은 모든 노드의 서브 트리 간 높이 차이가 1 이하인 것을 의미한다.

Input 1)

```
[3, 9, 20, None, None, 15, 7]
```

Output 1)

서브트리 간 높이 차가 1 이하이므로 높이균형이다. `return True`

Input 2)

```
[1, 2, 2, 3, 3, None, None, 4, 4]
```

Output)

1의 왼쪽 서브트리 2와 오른쪽의 2는 높이 차이가 2다. 따라서 높이균형이 아님. `return False`

## A1) 재귀 구조로 높이 차이 계산

높이 균형은 매우 중요하다. 균형맞는 트리는 효율적이고 탐색도 좋다. 그렇게 하는 트리 중 하나는 AVL 트리다. 이 문제에서는 높이 균형이 맞는지 체크하는 코드를 살펴보자.

### 어프로치

1. 리프까지 내려간다.
2. 맨 마지막 가면 `left = 0, right = 0` 를 세팅하고
3. left, right가 -1이거나, `abs(왼쪽-오른쪽)` 가 1보다 크면 `-1` 리턴
4. 아니면 `max(left, right) + 1` 리턴 (점점 1씩 커지면서 내 높이를 위로 올리면서, 반대쪽 하고 비교할 수 있게 해줌)

### 특이사항

- `-1` 값이 리턴되면, 그 시점부터는 이미 불균형한 트리를 찾았다는 점이 된다.
- `abs(왼쪽-오른쪽) > 1` 인걸 찾는게 불균형한 트리를 찾는 로직이고
- `left == -1 or right == -1` 은 이미 찾았으니 나가겠다는 로직이다

# Q49) 최소 높이 트리

문제)

노드 갯수와 무방향 그래프를 입력받아 트리가 최소높이가 되는 루트의 목록을 리턴하시오.

Input 1)

```
n = 4, edges = [[1, 0], [1, 2], [1, 3]]
```

Output 1)

```
[1]
```

Input 2)

```
n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]
```

Output 2)

```
[3, 4]
```

설명 2)

- `3` 혹은 `4`가 루트가 되는 트리가 될 경우, 최대 높이 2인 트리가 된다.

## A1) 단계별 리프노드 제거

최소 높이를 구성하려면 가장 가운데 값이 루트여야 한다. 다시 말해 리프노드를 하나씩 제거하며 남은 값을 찾으면, 그 값이 가장 가운데에 있는 값이 될 수 있다는 것이다. 즉 남은 값을 루트로 하면 최소 높이를 구성할 수 있다는 뜻이다.

문제도 문제인데 조금 복잡한 Input 3을 구성해보자. 이를 통해서 문제를 해결해보도록 한다.

```
[[1, 3], [2, 3], [3, 4], [3, 5], [4, 6], [6, 10], [5, 7], [5, 8], [8, 9]]
```

### 어프로치

1. 입력값을 그래프로 구성한다 (이젠 알죠?)
   1. **다만**, 무방향 그래프고, 부모와 자식은 양쪽 노드 모두 **번갈아 가능**하다. (양방향 삽입 필요!)
2. 리프노드를 별도의 리스트에 담고
3. 루트노드만 남을 때 까지 제낀다(이 때 루트노드는 1개 혹은 2개가 됨을 인지한다).
   1. 마지막으로 남은 1개 혹은 2개의 리프노드는 곧 루트노드다.
4. 다 제끼고나서 남은 값이 루트노드다.

## 이진 탐색 트리

이진트리: 정렬여부 관계 없이 모든 노드가 둘 이하의 자식을 갖는 트리

이진 탐색 트리(Binary Search Tree, BST): **정렬된** 트리. 왼쪽 서브트리는 작은값, 오른쪽 서브트리는 크거나 같은값을 가진다. 탐색 시간복잡도는 `O(log n)` 이다. 그런데 그러려면 트리의 균형이 맞아야 한다. 균형이 한참 깨지면(skewed) `O(n)` 에 근접한 시간이 소요될 수 있다. 이러면 연결리스트와 다를 바가 없다. 따라서, '자가 균형 이진 탐색 트리'라는 것이 등장하게 되었다.

### 자가 균형 이진 탐색 트리

> 자가 균형(혹은 높이 균형) 이진 탐색 트리는 삽입, 삭제 시 자동으로 높이를 작게 유지하는 노드 기반의 이진 탐색 트리이다.

자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)는 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.

예를 들어, 노드가 1M개 있다면 한방향으로 쏠린 아이템을 찾을 때는 1M번의 연산을 해야하지만, 완전히 균형을 잘 잡았다면 `log2 1M` 만에 연산이 가능하다.

이러한 트리로는 AVL트리, 레드-블랙 트리 등이 있다. 자바의 해시맵에서도 해시 테이블의 개별 체이닝 시 연결리스트와 함께 레드-블랙 트리를 병행사용한다.

# Q50) 정렬된 배열의 이진 탐색 트리 변환

문제)

오름차존으로 정렬된 배열을 높이 균형(Height Balanced) 이진 탐색 트리로 변환하시오.

Input)

```
[-10, -3, 0, 5, 9]
```

Output)

```
[0, -3, 9, -10, None, 5]
```

## A1) 이진 검색 결과로 트리 구성

**정렬된 배열**을 이진검색으로 쪼개면 된다.

### 어프로치

- 중앙값은 `//` 연산자(나눈다. 단 내림값이자 `int` 타입의 숫자를 리턴한다)로 처리한다
- 좌측 우측은 슬라이스해서 처리한다.

# Q51) 이진 탐색 트리(BST)를 더 큰 수 합계 트리로

문제)

BST의 각 노드를 현재값보다 더 큰 값을 가진 모든 노드의 합으로 만드시오.

Input)

```
[4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]
```

Output)

```
[30, 36, 21, 36, 35, 26, 15, None, None, None, 33, Null, Null, 8]
```

설명)

- 자신보다 더 큰 값을 가진 모든 노드의 합이 출력됨.
  - E.g., `6`의 경우 더 큰 값을 지닌 노드는 `7`, `8` → 이를 모두 더한 `6+7+8=21` 이 됨.
  - 큰값 뿐 아니라 자기 자신을 더한다

## A1) 중위 순회로 노드 값 누적

자신보다 같거나 큰 값은, 자신을 포함한 우측 자식 노드의 합으로 구할 수 있다. BST의 우측 자식은 항상 부모보다 크다. 이에 착안하여 코드를 살펴보자.

### 어프로치

- 루트를 받고, 맨 오른쪽 끝까지 내려가고, 부모 노드, 왼쪽 노드 순으로 움직이며 자신의 값을 포함해 누적한다. 이는 중위 순회(In-Order)라고 한다.
- 누적된 값을 변수로 담고있고, TreeNode.val에 현재 노드의 값을 저장해둔다.
- 쫓아가보면 그렇게 어렵지 않음을 알 수 있다.

# Q52) 이진 탐색 트리(BST) 합의 범위

문제)

이진 탐색 트리(BST)가 주어졌을 때, `L` 이상 `R` 이하의 값을 지닌 노드의 합을 구하시오.

Input)

```
root = [10, 5, 15, 3, 7, None, 18], L = 7, R = 15
```

Output)

```
32
```

설명)

`7`이상 `15`이하인 또 다른 노드는 `10`이 있다. 따라서 결과는 `7+10+15=32` 이다.

## A1) 재귀 구조 DFS로 "브루트 포스" 탐색

DFS로 전체를 탐색한다. 노드의 값이 `L`, `R` 사이면 값을 부여한다. 아니면 0을 취해 계속 더해나간다.

## A2) DFS "가지치기"로 필요한 노드만 골라 탐색

`L`, `R` 의 조건에 해당하지 않는 가지만 쳐내는 형태로 탐색해보자.

### 어프로치

1. val값이 L보다 작으면 안가고 우측
2. val 값이 R보다 크면 안가고 좌측

## A3) 반복 구조 DFS로 필요한 노드 탐색 (가지치기 포함)

A2를 반복으로 바꿔보자. 스택에 쌓고 한개씩 팝하는 식으로 간다.

## A4) 반복 구조 BFS로 필요한 노드 탐색 (가지치기 포함)

deque를 써서 BFS로 검색한다.

# Q53) 이진 탐색 트리(BST) 노드 간 최소 거리

문제)

두 노드 간 값의 차이가 가장 작은 노드의 값의 차이를 출력하시오.

Input 1)

```
root = [4, 2, 6, 1, 3, None, None]
```

Output 1)

```
1
```

설명 1)

노드 3, 노드 4의 값 차이는 `1` 이다. 차이가 `1`, `1`, `2`, `2` 라, 가장 작은 값인 0만 그냥 리턴하면 된다.

Input 2)

```
root = [10, 4, 15, 1, 8, None, None]
```

Output 2)

```
2
```

설명 2)

8, 10의 차이가 가장 작다.

## A1) 재귀 구조로 중위 순위

### 어프로치

1. 왼쪽 트리의 가장 오른쪽은 중앙보다 항상 작다
2. 오른쪽 트리의 가장 왼쪽은 중앙보다 항상 크다
3. 반드시 정답이진 않겠지만, 이런 식으로 각 서브트리별 중위순회를 계속 재귀로 하면?

## A2) 반복 구조로 중위 순위

### 어프로치

- 오른쪽 자식 노드를 택하기 전에 바로 비교를 수행한다.
- 스택에 왼쪽 들어갔다가 오른쪽 나오는 건 `while node` 구문에서 처리한다

## 트리 순회

> 트리 순회란 그래프 순회의 한 형태로 트리 자료구조에서 각 노드를 정확히 한 번 방문하는 과정을 의미한다.

트리 순회(Tree traversals) 또한 BFS, DFS로 탐색한다. 특히 이진트리에서 DFS는 노드의 방문 순서에 따라 3가지 방식으로 구별할 수 있다.

1. 전위(Pre-order) 순회(NLR)
2. 중위(In-order) 순회(LNR)
3. 후위(Post-order) 순회(LRN)

여기서 L은 현재노드의 왼쪽 서브트리, N은 현재 노드 자신, R은 현재 노드의 오른쪽 서브트리를 의미한다.

### 전위순회

- 일단 방문하고 왼쪽 오른쪽

### 중위순회

- 왼쪽 찍고 방문하고 오른쪽

### 후위순회

- 왼쪽 찍고 오른쪽 찍고나서 방문
