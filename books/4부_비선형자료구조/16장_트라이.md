# Trie

> 컴퓨터 과학에서 디지털 트리 또는 접두사 트리라고도 하는 _"트라이"_[1]는 세트 내에서 특정 키를 찾는 데 사용되는 트리 데이터 구조인 k-ary 검색 트리의 한 유형입니다. 이러한 키는 대부분 전체 키가 아니라 개별 문자로 정의된 노드 사이의 링크가 있는 문자열입니다. 키에 액세스하기 위해(값을 복구하거나 변경하거나 제거하기 위해) 트리는 키의 각 문자를 나타내는 노드 사이의 링크를 따라 깊이 우선 순회됩니다.

NLP에서 문자열 탐색을 위한 자료구조로 널리 쓰인다._"retrieval"_ 의 중간에서 음절을 따와서 Tree라고 부르다가 Trie라고 부르기도 한다. 트라이는 다진 트리 (k-ary Tree)의 형태를 띤다.

트라이는 각각의 문자 단위로 색인을 구축한 것과 유사하다. 단어별로 다진 트리를 쭉 만들고 탐색을 진행하면 굉장히 빨리 탐색할 수 있다. 즉, 문자의 갯수만큼 자식이 있다 할 수 있겠다. 문제를 통해, 트라이 구현 및 관련 문제를 풀어보도록 하자.

# Q56) 트라이 구현

문제)

트라이의 `insert`, `search`, `starts_with` 메소드를 구현하시오.

E.g.,

```python
trie = Trie()
trie.insert("apple")
trie.search("apple")        # returns True
trie.search("app")          # returns False
trie.starts_with("app")     # returns True
trie.insert("app")
trie.search("app")          # returns True
```

## A1) 딕셔너리를 이용하여 트라이 구현(간략화됨)

트라이를 저장할 노드는 클래스로 정하고, 트라이도 클래스로 한 후, 그 값을 루트로 저장하도록 하면 보다 구현하기 쉽다.

### 어프로치

- `TrieNode` 는 word라는 변수와 children이란 변수가 있다
  - `word`: insert 한 단어의 끝을 표현
  - `children`: 현재 노드 아래의 단어에 대한 `TrieNode` 값이 있다.
- `search()` 는 끝까지 찾았을 때 이게 단어인지 아닌지를 판별한다.
- `starts_with()` 는 여기까지 쫓아가지는지를 판별한다.

# Q57) 팰린드롬 페어

문제)

단어 리스트에서 `words[i] + words[j]` 가 팰린드롬이 되는 모든 인덱스 조합 `(i, j)` 를 구하시오.

Input 1)

```
["abcd", "dcba", "lls", "s", "sssll"]
```

Output 1)

```
[[0, 1], [1, 0], [3, 2], [2, 4]]
```

설명 1)

아래 `(i, j)` 인덱스 조합에 대한 값들이 팰린드롬이다.

```
["dcbaabcd"] # 1, 0 조합
["abcddcba"] # 0, 1 조합
["slls"] # 3, 2조합
["llssssll"] # 2, 4조합
```

Input 2)

```
["bat", "tab", "cat"]
```

Output 2)

```
[[0, 1], [1, 0]]
```

설명 2)

아래 `(i, j)` 인덱스 조합에 대한 값들이 팰린드롬이다.

```
["battab"] # 0, 1
["tabbat"] # 1, 0
```

## A1) 팰린드롬을 브루트 포스로 계산

모든 조합을 구성해보고 이게 팰린드롬이면 리턴. a, b두개에 대해 모두 구동하기 때문에 시간 복잡도는 `O(n^2)`이다.

값 꺼내서 같은지 찾는 로직은 단순히 `True if word == word[::-1] else False` 로도 해결되고 또 빠르기도 했다만, 시간복잡도가 있어서 느릴 듯 하다... 좀더 효율적으로 풀려면?

## A2) 트라이 구현

트라이 구현을 가져오고 비즈니스 로직을 추가해보자. 모든 입력값을 Trie로 만들고, 딱 한번만 탐색하도록 하면 될 듯 하다.

로직이 전반적으로 복잡하니, 꼭 직접 쫓아가고 메모리를 보면서 이해해야한다.

여기서 사용할 예시값은 아래와 같다:

```
['d', 'cbbcd', 'dcbb', 'dcbc', 'cbbc', 'bbcd']
```

### 어프로치

1. 입력값을 뒤집어서 트라이로 구축한다.
2. 단어단위는 `word_id` 로 표기한다. `insert()` 로직 내에서, 해당 단어의 인덱스 또한 저장하도록 한다.

### 주요 로직 (1)

순서대로 탐색하다가, 끝나는 지점의 `word_id` 값이 `-1`이 아니면 팰린드롬이다.

E.g.,

- `bbcd` 의 트라이 탐색이 끝나는 지점에는 `word_id = 2` 가 있다. `bbcd`의 인덱스는 `5`다.
- `bbcd` 와 `dcbb` 는 팰린드롬이다.

### 주요 로직 (2)

트라이 삽입 중에 남아있는 단어가 팰린드롬이라면 미리 팰린드롬 여부를 설정한다.

E.g.,

- `cbbc` 는 단어 자체가 팰린드롬이다.
- 루트에 바로 입력값의 인덱스인 `p = 4` (`palindrome_word_ids`)를 세팅한다.
- `word[0:len(word) - 1]` 형태로 단어에서 문자 수를 줄여나가며 팰린드롬 여부를 체크한다.
- 문자가 하나만 남으면 항상 팰린드롬이다. 따라서 `p = 4`를 마지막에 설정한다.
  - 이 값은 항상 `word_id` 의 바로 앞 노드가 된다.

### 주요 로직 (3)

입력값을 문자 단위로 확인해나가다가 해당 노드의 `word_id` 가 -1이 아닐 때, 나머지 문자가 팰린드롬이라면 팰린드롬으로 판별한다. (이건 가장 쉬운로직!)
